<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_0362g" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>Introduction to the Xilinx Programmable Logic Device (PLD)</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">The document has a title page which contains:
document title
title part</note><note resp="British Academic Written English (BAWE) corpus project">Language used in quote: <foreign id="English">English</foreign></note><note resp="British Academic Written English (BAWE) corpus project">comment@0361h
deleted: footer: student page and module numbers
comment@0361h
Appendix: commented computer code</note></notesStmt><sourceDesc><p n="level">2</p><p n="date">2006-12</p><p n="module title">Digital Systems Design</p><p n="module code">ES3B2</p><p n="genre family">Methodology recount</p><p n="discipline">Engineering</p><p n="disciplinary group">PS</p><p n="grade">D</p><p n="number of authors">1</p><p n="number of words">3501</p><p n="number of s-units">152</p><p n="number of p">67</p><p n="number of tables">12</p><p n="number of figures">7</p><p n="number of block quotes">8</p><p n="number of formulae">0</p><p n="number of lists">1</p><p n="number of paragraphs formatted like lists">8</p><p n="abstract present">no abstract</p><p n="average words per s-unit">23.0</p><p n="average s-units per p">2.3</p><p n="macrotype of assignment">simple assignment</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">f</p><p n="year of birth">1985</p><p n="first language">Gujarati</p><p n="education">OSA</p><p n="course">Meng Electronics</p><p n="student ID">0362</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><titlePart>THE UNIVERSITY OF <name type="university"/> School Of Engineering</titlePart><docTitle><titlePart rend="underlined bold">Digital Systems Design Introduction to the Xilinx Programmable Logic Device (PLD)</titlePart></docTitle><titlePart>BY STUDENT ID: <name type="student ID"/> REPORT REFERENCE CODE: [ES3B2A3] AFFLIATION: [YEAR 3 ENGINEERING]<hi rend="bold"> ES3B2- Assignment3</hi> REPORT PERFORMED ON: 6 <hi rend="sup">TH</hi> December 2006</titlePart></titlePage><div1 type="toc" n="1"><head rend="underlined bold">CONTENTS:</head><p/></div1></front><body><div1 type="section"><head rend="bold">Introduction</head><p n="p1.67"><s n="s1.2;p1.67">The aim of these laboratories is to provide an introduction to some of the features of a Xilinx ISE and Spartan-3 FPGA board as well as to get familiar with VHDL codes to help write Xilinx ISE program on Spartan 3FPGA board. </s><s n="s2.2;p1.67">The codes and comments are written and programmed in Xilinx ISE 8.2i which provided the environment required to program the board. </s></p><p n="p2.67"><s n="s1.1;p2.67">The device used in the laboratory XC3S1000 is of the family Spartan 3. </s></p><p n="p3.67"><s n="s1.1;p3.67">The following is the table showing the summary of the device XC3S1000 FPGA in a 256 ball thin Grid Array: </s></p><table id="BAWE_0362g-tab.001"><head rend="bold"> Table1: Summary of XC3S1000</head><row><cell/></row></table><p n="p4.67"><s n="s1.1;p4.67">With reference from the handouts the main objectives of lab5 and lab6 was to carry out the following: </s></p><list type="ordered"><item>To study and understand the program ANDGATE and counter using tutorials. </item><item>To follow the steps given in the laboratory handouts to create the program and then simulate it. </item><item>To observe whether or not the program functioned as required. </item><item>Assign pins and transfer the program to the board. </item><item>Observe the results when the switches are ON </item><item>To study and understand the working of Dflipflops and 7segment LEDs </item><item>Define the inputs and outputs. </item><item>To create program and VHDL file with codes for the working. </item><item>To get graphs demonstrating the working of the codes</item><item>Assign pins responsible for each inputs and outputs. </item><item>Transfer the program to the board</item><item>Observe the changes or results obtained </item></list></div1><div1 type="section"><head rend="bold">Theory</head><div2><head rend="bold">4 Digit- 7segment LEDS:</head><p n="p5.67"><s n="s1.5;p5.67">The working of four 7 segment LEDs used in the board. </s><s n="s2.5;p5.67">The Spartan-3 board has a four-character, seven segments LED display controlled by FPGA user-I/O pins, as shown in Figure 1. </s><s n="s3.5;p5.67">Each digit shares eight common control signals to light individual LED segments. </s><s n="s4.5;p5.67">Each individual character has a separate anode control input. </s><s n="s5.5;p5.67">A detailed schematic for the display appears in Figure A. </s></p><p n="p6.67"><s n="s1.1;p6.67">The pin number for each FPGA pin connected to the LED display appears in parentheses. </s></p><p n="p7.67"><s n="s1.8;p7.67">To light an individual signal, drive the individual segment control signal Low along with the associated anode control signal for the individual character. </s><s n="s2.8;p7.67">In Figure 1, for example, the left-most character displays the value '2'. </s><s n="s3.8;p7.67">The digital values driving the display in this example are shown in blue. </s><s n="s4.8;p7.67">The AN3 anode control signal is Low, enabling the control inputs for the left-most character. </s><s n="s5.8;p7.67">The segment control inputs, A through G and DP, drive the individual segments that comprise the character. </s><s n="s6.8;p7.67">A Low value lights the individual segment, a High turns off the segment. </s><s n="s7.8;p7.67">A Low on the A input signal, lights segment 'a' of the display. </s><s n="s8.8;p7.67">The anode controls for the remaining characters, AN[2:0] are all High, and these characters ignore the values presented on A through G and DP. </s></p><figure id="BAWE_0362g-pic.001"><head rend="bold">Figure1: Seven Segment LED digital control</head></figure><p n="p8.67"><s n="s1.2;p8.67">Table 2 lists the FPGA connections that drive the individual LEDs comprising a seven segment character. </s><s n="s2.2;p8.67">Table 3 lists the connections to enable a specific character. </s></p><table id="BAWE_0362g-tab.002"><head rend="bold">Table 2: FPGA connections to individual seven-segment LED display segments</head><row><cell/></row></table><table id="BAWE_0362g-tab.003"><head rend="bold">Table 3: FPGA connections to the anode controls for each seven-segment display</head><row><cell/></row></table><figure id="BAWE_0362g-fig.001"><head rend="bold">FigureA: Side switches, pushbutton, LEDs, four seven segment LEDs</head></figure><p n="p9.67"><s n="s1.3;p9.67">The LED control signals are time-multiplexed to display data on all four characters, as shown in Figure 3. </s><s n="s2.3;p9.67">Present the value to be displayed on the segment control inputs and select the specified character by driving the associated anode control signal Low. </s><s n="s3.3;p9.67">Through persistence of vision, the human brain perceives that all four characters appear simultaneously, similar to the way the brain perceives a TV display. </s></p><figure id="BAWE_0362g-fig.002"><head rend="bold">Figure3: Drive anode inputs low to light individual character</head></figure><p n="p10.67"><s n="s1.4;p10.67">This "scanning" technique reduces the number of I/O pins required for the four characters. </s><s n="s2.4;p10.67">If an FPGA pin were dedicated for each individual segment, then 32 pins are required to drive four 7-segment LED characters. </s><s n="s3.4;p10.67">The scanning technique reduces the required I/O down to 12 pins. </s><s n="s4.4;p10.67">The drawback to this approach is that the FPGA logic must continuously scan data out to the displays - a small price to save 20 additional I/O pins. </s></p></div2><div2><head rend="bold">Slide switches:</head><p n="p11.67"><s n="s1.5;p11.67">The switches are located along the lower edge of the board, toward the right edge. </s><s n="s2.5;p11.67">The switches are labeled SW7 through SW0. </s><s n="s3.5;p11.67">Switch SW7 is the left-most switch, and SW0 is the rightmost switch. </s><s n="s4.5;p11.67">The switches connect to an associated FPGA pin, as shown in Table 4. </s><s n="s5.5;p11.67">A detailed schematic appears in Figure A. </s></p><table id="BAWE_0362g-tab.004"><head rend="bold">Table 4: FPGA connections to slide switches SW0 to SW7</head><row><cell/></row></table><p n="p12.67"><s n="s1.1;p12.67">When in the UP or ON position, a switch connects the FPGA pin to VCCO, a logic High. </s></p><p n="p13.67"><s n="s1.3;p13.67">When DOWN or in the OFF position, the switch connects the FPGA pin to ground, a logic Low. </s><s n="s2.3;p13.67">The switches typically exhibit about 2 ms of mechanical bounce and there is no active debouncing circuitry, although such circuitry could easily be added to the FPGA design programmed on the board. </s><s n="s3.3;p13.67">A 4.7KΩ series resistor provides nominal input protection. </s></p></div2><div2><head rend="bold">Push Buttons:</head><p n="p14.67"><s n="s1.5;p14.67">These push buttons are located along the lower edge of the board, toward the right edge. </s><s n="s2.5;p14.67">The switches are labeled BTN3 through BTN0. </s><s n="s3.5;p14.67">Push button switch BTN3 is the left-most switch, BTN0 the right-most switch. </s><s n="s4.5;p14.67">The push button switches connect to an associated FPGA pin, as shown in Table 5. </s><s n="s5.5;p14.67">A detailed schematic appears in Figure A. </s></p><table id="BAWE_0362g-tab.005"><head rend="bold">Table 5: FPGA connections to buttons BTN0 to BTN3</head><row><cell/></row></table><p n="p15.67"><s n="s1.5;p15.67">Pressing a push button generates logic High on the associated FPGA pin. </s><s n="s2.5;p15.67">Again, there is no active debouncing circuitry on the push button. </s><s n="s3.5;p15.67">The left-most button, BTN3, is also the default User Reset pin. </s><s n="s4.5;p15.67">BTN3 electrically behaves identically to the other push buttons. </s><s n="s5.5;p15.67">However, when applicable, BTN3 resets the provided reference designs. </s></p></div2><div2><head rend="bold">LEDS:</head><p n="p16.67"><s n="s1.4;p16.67">The Spartan-3 Starter Kit board has eight individual surface-mount LEDs located above the push button switches. </s><s n="s2.4;p16.67">The LEDs are labeled LED7 through LED0. </s><s n="s3.4;p16.67">LED7 is the left-most LED, LED0 the right-most LED. Table 6 shows the FPGA connections to the LEDs. </s><s n="s4.4;p16.67">A detailed schematic appears in Figure A. </s></p><table id="BAWE_0362g-tab.006"><head rend="bold">Table 6: FPGA connections to LEDs LD0 to LD7</head><row><cell/></row></table><p n="p17.67"><s n="s1.2;p17.67">The cathode of each LED connects to ground via a 270Ω resistor. </s><s n="s2.2;p17.67">To light an individual </s></p><p n="p18.67"><s n="s1.1;p18.67">LED, drive the associated FPGA control signal High, which is the opposite polarity from lighting one of the 7-segment LEDs. </s></p></div2><div2><head rend="bold">Dflipflop:</head><p n="p19.67"><s n="s1.7;p19.67">The operation of Dflipflop is simple. </s><s n="s2.7;p19.67">It has only one input in addition to the clock input signal. </s><s n="s3.7;p19.67">The dflipflop used in the program was positive triggered. </s><s n="s4.7;p19.67">The D input is sampled during the occurrence of a clock pulse. </s><s n="s5.7;p19.67">If it is 1, the flip-flop is switched to the set state (unless it was already set). </s><s n="s6.7;p19.67">If it is 0, the flip-flop switches to the clear state. </s><s n="s7.7;p19.67">The Figure4 shows the symbol of the Dflipflop and table 7 is the truth table and figure 5 shows the output of the Dflipflop. </s></p><figure id="BAWE_0362g-pic.002"><head rend="bold">Figure4: Dflipflop</head></figure><table id="BAWE_0362g-tab.007"><head rend="bold">Table7: truth table for positive triggered Dflipflop</head><row><cell/></row></table><figure id="BAWE_0362g-fig.003"><head rend="bold">Figure5 : Positive edge triggered Dflipflop output</head></figure></div2><div2><head rend="bold">Converting decimal into 4 bit binary number: </head><p n="p20.67"><s n="s1.3;p20.67">Binary is Base 2 unlike our counting system decimal which is Base 10 (denary). </s><s n="s2.3;p20.67">In other words, <hi rend="bold">Binary</hi> has only <hi rend="bold">2</hi> different numerals (0 and 1), unlike <hi rend="bold">Decimal</hi> which has <hi rend="bold">10</hi> numerals (0,1,2,3,4,5,6,7,8 and 9). </s><s n="s3.3;p20.67">Here is an example of a binary number: 1001 is a 4 bit representation of the decimal '9'. </s></p><table id="BAWE_0362g-tab.008"><row><cell/></row></table><p n="p21.67"><s n="s1.2;p21.67">Bit is short for Binary Digit, and each numeral is classed as a bit. </s><s n="s2.2;p21.67">The bit on the far right (in this case a zero) is known as the <hi rend="bold">Least significant bit (LSB)</hi>, and the bit on the far left (in this case a 1) is known as the <hi rend="bold">Most significant bit (MSB)</hi> </s></p></div2></div1><div1 type="section"><head rend="bold">Apparatus and Method:</head><p n="p22.67"><s n="s1.1;p22.67">The hardware elements featured in the laboratories were: Spartan 3 board, Digilent JTAG Cable, XC3S1000 device, USB cable to power the board. </s></p><p n="p23.67"><s n="s1.4;p23.67">Firstly I connected Spartan 3 board to a PC and powered up board using the USB cable, followed by connecting the Digilent JTAG cable. </s><s n="s2.4;p23.67">Digilent JTAG cable is used to transfer data on to the board from the computer. </s><s n="s3.4;p23.67">I followed the tutorial given in the laboratory sheet for ANDGATE to study and understand the procedure and working of the software. </s><s n="s4.4;p23.67">I also followed the quick tutorial provided in the laboratory to make a 4 bit counter. </s></p><p n="p24.67"><s n="s1.2;p24.67">After, the completion of the program I downloaded the program on the board and observed the results, which were as expected. </s><s n="s2.2;p24.67">I tried to relate the pins associated with each buttons, switches, LEDS, and 7 segment LEDS using the appendix A of the laboratory sheet. </s></p><p n="p25.67"><s n="s1.3;p25.67">To make a Dflipflop program I firstly, made a note of the input and outputs needed for the program as CLK- clock input, D- D input, Q- Output. </s><s n="s2.3;p25.67">As explained earlier in theory section learned about the working of Dflipflop. </s><s n="s3.3;p25.67">I followed the method similar to the laboratory sheet provided to create and run the program. </s></p><p n="p26.67"><s n="s1.1;p26.67">To make a counter from 0-9 on one of the four 7segment LED I used the method described in the theory to workout the codes and followed the instructions similar to those given in laboratory sheet to create and run the program. </s></p></div1><div1 type="section"><head rend="bold">Codes Explanation:</head><div2><head rend="bold">DFLIPFLOP</head><quote lang="English"><hi rend="bold">library IEEE; use IEEE.STD_LOGIC_1164.ALL;</hi><hi rend="bold"> use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL;</hi></quote><p n="p27.67"><s n="s1.2;p27.67">Some of the files and logic defined in other locations are used in the program. </s><s n="s2.2;p27.67">Hence the above statements are used. </s></p><quote lang="English"><hi rend="bold">---- Uncomment the following library declaration if instantiating ---- any Xilinx primitives in this code.</hi> <hi rend="bold"> --library UNISIM; --use UNISIM.VComponents.all;</hi><hi rend="bold"> entity DFLIPFLOP is</hi> ---describes the design I/O of DFLIPFLOP. <hi rend="bold">Port ( D : in STD_LOGIC;</hi> ----D is an entity that goes in but not out. <hi rend="bold">CLK : in STD_LOGIC</hi>; ----CLK is an entity that goes in but not out. CLK is the input clock signal for the Dflipflop. <hi rend="bold">Q : out STD_LOGIC);</hi> ----Q is an entity that goes out but not in. <hi rend="bold"> end DFLIPFLOP;</hi> ----end the entity of DFLIPFLOP</quote><p n="p28.67"><s n="s1.4;p28.67">Here in total 3 entities are described. </s><s n="s2.4;p28.67">CLK and D is input signals and Q is the output signal. </s><s n="s3.4;p28.67">Every potential connection is known as port and is given a name that is unique with in the entity. </s><s n="s4.4;p28.67">Port is a signal that contains both MODE and TYPE. MODE is the input, output or bidirectional assigned to the entity and TYPE is the value the port can take like 0, 1, 3state. </s></p><quote lang="English"><hi rend="bold">architecture Behavioral of DFLIPFLOP is</hi>----describes the content of the design <hi rend="bold"> begin</hi> --begins architectural behaviour</quote><p n="p29.67"><s n="s1.4;p29.67">In PROCESS statements are evaluated sequentially in terms of simulation. </s><s n="s2.4;p29.67">It becomes active when the sensitivity list changes the value. </s><s n="s3.4;p29.67">All signal assignments occur at the END PROCESS statements in terms of simulation time. </s><s n="s4.4;p29.67">The process then becomes in active. </s></p><quote lang="English"><hi rend="bold">process (CLK)</hi> -----process is active when there is any change in input <hi rend="bold"> begin if CLK'event and CLK='1' then</hi> ---this statement detects rising clock edge, using the IF condition. With the condition to detect if CLK is high i.e. '1' <hi rend="bold">Q &lt;= D;</hi> -----the output Q equals to input D everytime clock is high i.e. '1' <hi rend="bold">end if</hi>; --end the condition if for CLK <hi rend="bold"> end process; ---</hi>end the process for CLK and signal assignment occurs. <hi rend="bold"> end Behavioral</hi>;--end the architectural behaviour of DFLIPFLOP. <hi rend="bold"> 7Segment LED 0-9 count: library IEEE;</hi><hi rend="bold"> use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL;</hi><hi rend="bold"> use IEEE.STD_LOGIC_UNSIGNED.ALL;</hi></quote><p n="p30.67"><s n="s1.2;p30.67">Some of the files and logic defined in other locations are used in the program. </s><s n="s2.2;p30.67">Hence the above statements are used. </s></p><quote lang="English">---- Uncomment the following library declaration if instantiating ---- any Xilinx primitives in this code. --library UNISIM; --use UNISIM.VComponents.all;<hi rend="bold"> entity LED7 is</hi> - describes the design I/O of LED7 Port <hi rend="bold">( ENABLE : OUT STD_LOGIC_VECTOR (3 downto 0);</hi> ENABLE is an entity that goes out but not in. <hi rend="bold"> LED</hi> <hi rend="bold">: out STD_LOGIC_VECTOR (6 downto 0)</hi>; LED is an entity that goes out but not in <hi rend="bold">CLK : in STD_LOGIC)</hi>;--CLK is an entity that goes in but not out <hi rend="bold"> end</hi> <hi rend="bold">LED7;</hi> --end the entity of LED7</quote><p n="p31.67"><s n="s1.2;p31.67">There are in total 3 variables assigned ENABLE, LED CLK. ENABLE is an as described in the theory section. </s><s n="s2.2;p31.67">It is used to display the number on 7 segment LED. It can help to turn off some or turn on the four 7 segment LEDs on the board. </s></p><p n="p32.67"><s n="s1.1;p32.67">LED stands for the 7 segments in the 7 segment LED and it helps to make it active low or high to display different numbers 0-9. </s></p><p n="p33.67"><s n="s1.2;p33.67">CLK is used for the push button. </s><s n="s2.2;p33.67">It is assigned active high if the push button is pressed. when u push the button, the associated FPGA pin is connected to the power line (a logic "1") and when not pressed the associated FPGA pin is connected to 0V(a logic"0"). </s></p><quote lang="English"><hi rend="bold">architecture Behavioral of LED7 is</hi> - describes the design of LED7 <hi rend="bold"> signal count:std_logic_vector (3 downto 0) :="0000";</hi></quote><p n="p34.67"><s n="s1.2;p34.67">Signal carries all VHDL information. </s><s n="s2.2;p34.67">Count is an array and is assigned in a descending order count0-3 </s></p><quote lang="English"><hi rend="bold">Begin</hi> - begin the architectural behaviour of LED7 <hi rend="bold"> process(CLK)</hi> - process is active each time input signal CLK changes <hi rend="bold"> begin</hi> - begin process <hi rend="bold"> ENABLE(0) &lt;='0';</hi> -----enable(0) is assigned 0 means it is active low hence, will help display number. Meaning that the an(0) as described in the theory section will become low and hence, the first 7 segment LED will be active low. <hi rend="bold"> ENABLE(1) &lt;='1';</hi> -----enable(1) is assigned 1 means it is active high so it will be OFF, and will not display any number. Meaning that the an(1) as described in the theory section will become active high and hence, the second 7segnment LED will be active low. <hi rend="bold"> ENABLE(2) &lt;='1';</hi> -----enable(2) is assigned 1 means it is active high so it will be OFF, and will not display any number. Meaning that the an(2) as described in the theory section will become active high and hence, the second 7segnment LED will be active low. <hi rend="bold"> ENABLE(3) &lt;='1';</hi> ------enable(3) is assigned 1 means it is active high so it will be OFF, and will not display any number. Meaning that the an(3) as described in the theory section will become active high and hence, the second 7segnment LED will be active low. <hi rend="bold"> if CLK='1' and CLK'event then</hi> - detects everytime CLK is rising high <hi rend="bold">if count ="1001" then</hi> - checks if count is equal to '9' <hi rend="bold">count &lt;= "0000";</hi> --then changes the count to '0'. Hence makes a loop of 0-9 and it again starts from 0 each time push button is pressed one more time after it has reached 9. <hi rend="bold"> else count&lt;= count + 1;</hi> --otherwise increase the value of count by '1' each time <hi rend="bold"> end if;</hi> --end of the condition for count <hi rend="bold"> end if;</hi> --end of condition for CLK <hi rend="bold"> case count is when "0000" => LED &lt;= "1000000";</hi> --when count is '0000', display '0' on LED. <hi rend="bold"> when "0001" => LED &lt;= "1111001";--</hi>when count is '0001', display '1' on LED <hi rend="bold"> when "0010" => LED &lt;= "0100100";--</hi>when count is '0010', display '2' on LED <hi rend="bold"> when "0011" => LED &lt;= "0110000";</hi>--when count is '0011', display '3' on LED <hi rend="bold"> when "0100" => LED &lt;= "0011001";</hi>--when count is '0100', display '4' on LED <hi rend="bold"> when "0101" => LED &lt;= "0010010";</hi>--when count is '0101', display '5' on LED <hi rend="bold"> when "0110" => LED &lt;= "0000010";</hi>--when count is '0110', display '6' on LED <hi rend="bold"> when "0111" => LED &lt;= "1111000";</hi>--when count is '0111', display '7' on LED <hi rend="bold"> when "1000" => LED &lt;= "0000000";</hi>--when count is '1000', display '8' on LED <hi rend="bold"> when "1001" => LED &lt;= "0010000";</hi>--when count is '1001', display '9' on LED <hi rend="bold"> when others => LED&lt;="0000000";</hi>--when count is different value, display '8' on LED</quote><p n="p35.67"><s n="s1.1;p35.67">Here, the count is assigned numbers 0-9 in the binary form as 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001 and when it is different from those it is assigned 8. </s></p><p n="p36.67"><s n="s1.1;p36.67">The way of converting decimal into binary is explained in detail in theory. </s></p><quote lang="English"><hi rend="bold">end case;</hi> --end the case for count <hi rend="bold"> end process</hi>; --end the process for CLK <hi rend="bold"> end Behavioral;</hi> --end the architectural behaviour for LED7</quote></div2></div1><div1 type="section"><head rend="bold">Assigning Pins: </head><p n="p37.67"><s n="s1.1;p37.67">The following steps found in the laboratory sheet under section 3.2.4 were followed to assign pins for all the programs: </s></p><div2><head rend="underlined bold">3.2.4 Assigning Pin Locations </head><p rend="ordered" n="p38.67"><s n="s1.3;p38.67">1. </s><s n="s2.3;p38.67">Verify that <hi rend="bold">Andgate</hi> is selected in the <hi rend="bold">Sources</hi> window (<hi rend="bold">Synthesis/Implementation)</hi>. </s><s n="s3.3;p38.67">Then Press Processes tab. </s></p><p rend="ordered" n="p39.67"><s n="s1.3;p39.67">2. </s><s n="s2.3;p39.67">Double-click the <hi rend="bold">Assign Package Pins</hi> process found in the <hi rend="bold">User Constraints</hi> process group. </s><s n="s3.3;p39.67">The Xilinx <hi rend="bold">Pinout</hi> and Area Constraints Editor (<hi rend="bold">PACE</hi>) opens. </s></p><p rend="ordered" n="p40.67"><s n="s1.2;p40.67">3. </s><s n="s2.2;p40.67">Select the <hi rend="bold">Package View</hi> tab. </s></p><p rend="ordered" n="p41.67"><s n="s1.2;p41.67">4. </s><s n="s2.2;p41.67">In the Design Object List window, enter a pin location for each pin in the <hi rend="bold">Loc</hi> column using the following information: </s></p><p rend="ordered" n="p42.67"><s n="s1.1;p42.67"><hi rend="bold">Input</hi> "a" connected to "J13" --- User button <hi rend="bold">BTN0</hi> </s></p><p rend="ordered" n="p43.67"><s n="s1.1;p43.67"><hi rend="bold">Input</hi> "b" connected to "K14" --- User button <hi rend="bold">BTN1</hi> </s></p><p rend="ordered" n="p44.67"><s n="s1.1;p44.67"><hi rend="bold">Output</hi> "c" connected to "L14" --- Led <hi rend="bold">LD0</hi> </s></p><p rend="ordered" n="p45.67"><s n="s1.3;p45.67">5. </s><s n="s2.3;p45.67">Select <hi rend="bold">File </hi>→<hi rend="bold">Save</hi>. </s><s n="s3.3;p45.67">Select <hi rend="bold">XST Default &lt;></hi> and click <hi rend="bold">OK</hi>. </s></p></div2><div2><head rend="bold">For assigning pins to ANDGATE: </head><p n="p46.67"><s n="s1.1;p46.67">The table 8 shows the pins assigned to each entity in ANDGATE program, and figure 6 shows the print screen of the assigned pins. </s></p><table id="BAWE_0362g-tab.009"><head rend="bold">Table8: ANDGATE pins</head><row><cell/></row></table><figure id="BAWE_0362g-pic.003"><head rend="bold">Figure6: ANDGATE pins assigned</head></figure></div2><div2><head rend="bold">Counter: </head><p n="p47.67"><s n="s1.1;p47.67">The table 9 shows the pins allocated and the figure 7 shows the pins assigned print screen. </s></p><table id="BAWE_0362g-tab.010"><head rend="bold">Table9: COUNTER pins</head><row><cell/></row></table><figure id="BAWE_0362g-pic.004"><head rend="bold">Figure7: Counter assigned pins</head></figure></div2><div2><head rend="bold">DFLIPFLOP</head><p n="p48.67"><s n="s1.2;p48.67">The table 10 and figure 8 shows the pins allocated for DFLIPFLOP. Here slide switches are used for inputs as it is easier than to push buttons. </s><s n="s2.2;p48.67">And also helps observing the results. </s></p><table id="BAWE_0362g-tab.011"><head rend="bold">Table10: Dflipflop assigned pins</head><row><cell/></row></table><figure id="BAWE_0362g-pic.005"><head rend="bold">Figure8: Dflipflop assigned pins</head></figure></div2><div2><head rend="bold">7segment display from 0-9: </head><p n="p49.67"><s n="s1.1;p49.67">The table 11 shows the assigned pins and figure 9 shows the print screen of the assigned pins: </s></p><table id="BAWE_0362g-tab.012"><head rend="bold">Table11: count 0-9 assigned pins </head><row><cell/></row></table><figure id="BAWE_0362g-pic.006"><head rend="bold">Figure9: count 0-9 assigned pins</head></figure></div2></div1><div1 type="section"><head rend="bold">Observations and results:</head><p n="p50.67"><s rend="bold" n="s1.1;p50.67">The simulation result of the ANDGATE is shown below: </s></p><figure id="BAWE_0362g-fig.004"/><p n="p51.67"><s n="s1.4;p51.67">It can be observed from the graph that c is only high when both a and b are high. </s><s n="s2.4;p51.67">Hence, it shows that the logic of c&lt;=a and b; works. </s><s n="s3.4;p51.67">When the program was loaded on the board it showed that the LD0 was ON only when both a and b were pressed together. </s><s n="s4.4;p51.67">When pressed alternatively or not pressed at all showed no result on LD0. </s></p><p n="p52.67"><s rend="bold" n="s1.1;p52.67">The simulation result of the counter is shown below: </s></p><figure id="BAWE_0362g-fig.005"/><p n="p53.67"><s n="s1.3;p53.67">It can be observed from the above graph that Count output for a 4 bit binary up/down counter. </s><s n="s2.3;p53.67">It can be observed that when DIRECTION input is high, the output count is incremented on the rising edge of the CLOCK input. </s><s n="s3.3;p53.67">But, when DIRECTION is set low, the output count is decremented on the rising edge of the CLOCK input. </s></p><p n="p54.67"><s n="s1.4;p54.67">When the program was loaded on the board it showed all LEDs off. </s><s n="s2.4;p54.67">When SW7 was down position and each time BTN0 was pressed the LEDs showed a sequence of output showing the down count. </s><s n="s3.4;p54.67">But when the SW7 was in up position and BTN 0 was pressed it showed sequence of output showing the up count. </s><s n="s4.4;p54.67">Hence, it worked as required. </s></p><p n="p55.67"><s rend="bold" n="s1.1;p55.67">The simulation output of the DFLIPFLOP is as shown below: </s></p><figure id="BAWE_0362g-fig.006"/><p n="p56.67"><s n="s1.2;p56.67">Every time when the CLK input experiences a rising edge, the output Q stores the state of the input D. However, until the CLK input goes for another rising edge, the output remains unchanged regardless of the D input. </s><s n="s2.2;p56.67">It can be noted here that the initial red line on the Q waveform represents an ambiguous condition, as the output has not been set yet. </s></p><p n="p57.67"><s n="s1.3;p57.67">When the program was loaded on the board, LD0 was OFF. When SW0 was moved to the up position, there was still no change on the LD0 until SW1 was then moved to the up position. </s><s n="s2.3;p57.67">Once this happened, LD0 turned ON. After this, moving SW0 between the 2 states did not affect the output. </s><s n="s3.3;p57.67">However, when SW0 was in the down position, and SW1 was moved from down to up, LD0 turned OFF. Hence, the result was as expected and showed the working of Dflipflop. </s></p><p n="p58.67"><s rend="bold" n="s1.1;p58.67">The simulation output of 7 segment display count 0-9: </s></p><figure id="BAWE_0362g-fig.007"/><p n="p59.67"><s n="s1.3;p59.67">The above graph shows that when CLK input is rising high, the output LED changes. </s><s n="s2.3;p59.67">It showed numbers from 0-9 every time when CLK input is rising high, it counted from 0-9 When it reached 9 it counted again from 0. </s><s n="s3.3;p59.67">The ENABLE output shows the correct output, as only one of the signals shows a low logic level. </s></p><p n="p60.67"><s n="s1.2;p60.67">When the program was loaded on the board the LED displayed 0 on only one 7 segment LED. Now, every time BTN0 was pressed it showed 0-9 and when it reached 9 it started counting from 0. </s><s n="s2.2;p60.67">Hence, it worked as required. </s></p></div1><div1 type="section"><head rend="bold">Conclusion:</head><p n="p61.67"><s n="s1.1;p61.67">The programs showed the required output on the simulation graphs and also performed as required when loaded on the board. </s></p><p n="p62.67"><s n="s1.1;p62.67">The DFLIPFLOP worked as required as it did the following: </s></p><p n="p63.67"><s n="s1.1;p63.67">When SW1 was high and SW0 was low the LD0 was OFF </s></p><p n="p64.67"><s n="s1.1;p64.67">When SW1 was low SW0 was high the LD0 was OFF </s></p><p n="p65.67"><s n="s1.1;p65.67">When SW1 was high and SW0 was high LD0 was ON, until once again SW1 was high but SW0 was low. </s></p><p n="p66.67"><s n="s1.1;p66.67">The 7 segment LED used to display count 0-9 worked as required as it did the following: </s></p><p n="p67.67"><s n="s1.1;p67.67">It displayed 0 to start with but everytime BTN0 was pressed it displayed 0-9 on just one 7 segment LED. And when the count reached 9 and BTN0 pressed again it counted again from 0-9. </s></p></div1></body><back><div1 type="appendix"><head rend="bold">Appendices:</head><p/></div1></back></text></TEI.2>
