<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_3052e" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>Coursework</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">The document has a title page which contains:
document title
title part</note></notesStmt><sourceDesc><p n="level">3</p><p n="date">2005-12</p><p n="module title">Distributed client-server systems</p><p n="module code">U08184</p><p n="genre family">Design specification</p><p n="discipline">Computer Science</p><p n="disciplinary group">PS</p><p n="grade">M</p><p n="number of authors">1</p><p n="number of words">2528</p><p n="number of s-units">141</p><p n="number of p">61</p><p n="number of tables">0</p><p n="number of figures">7</p><p n="number of block quotes">0</p><p n="number of formulae">5</p><p n="number of lists">1</p><p n="number of paragraphs formatted like lists">6</p><p n="abstract present">no abstract</p><p n="average words per s-unit">17.9</p><p n="average s-units per p">2.3</p><p n="macrotype of assignment">simple assignment</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">m</p><p n="year of birth">1985</p><p n="first language">French</p><p n="education">OSa</p><p n="course">Computing</p><p n="student ID">3052</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><titlePart rend="italic"><name type="student name"/> Student number: <name type="student ID"/></titlePart><titlePart rend="italic">Distributed Client/Server Systems (U08184)</titlePart><docTitle><titlePart rend="italic">Coursework </titlePart></docTitle><titlePart rend="italic">12th December 2005</titlePart></titlePage><div1 type="toc" n="3"><head rend="bold italic">Contents</head><p/></div1></front><body><div1 type="section"><head rend="bold italic">The different components contained in the program :</head><p n="p1.61"><s n="s1.3;p1.61">This system is a program which supervises an auction environment. </s><s n="s2.3;p1.61">It contains 3 servers and several (indeterminate number) sellers and bidders. </s><s n="s3.3;p1.61">This distributed system uses the Beowulf cluster. </s></p><div2><head rend="italic">The servers:</head><p n="p2.61"><s n="s1.2;p2.61">Each server runs on its own machine (one node in the cluster). </s><s n="s2.2;p2.61">One of the three servers is called "Root Server" because it will launch the two others and create three child processes which are used to synchronise the clock between the 3 servers (first child process), to accept connection from outside (from bidder or seller) (second child process) and the last one is the lock manager (a section below give more details about this lock manager). </s></p><p n="p3.61"><s n="s1.3;p3.61">So, the root server is composed by 4 processes. </s><s n="s2.3;p3.61">However only 2 tasks identifier are needed: one for the root server and the second for the lock manager. </s><s n="s3.3;p3.61">The two others processes don't need a PVM task id (however, they have one, the same than the root server, the parent, because the <hi rend="italic">fork()</hi> function copies all the parent environment to the child). </s></p><p n="p4.61"><s n="s1.4;p4.61">In order to create two different tasks identifier, the lock manager process has to be created before the first PVM function call. </s><s n="s2.4;p4.61">Then, the child and the parent will have different task id. </s><s n="s3.4;p4.61">However, the parent process has to know the lock manager task id for several reasons. </s><s n="s4.4;p4.61">So this communication is done via a pipe between the parent and the child process. </s></p><p n="p5.61"><s n="s1.1;p5.61">The root server runs on the node <hi rend="italic">Beowulf4</hi> and has to launch the two others servers via PVM on two others machines (the chosen nodes are <hi rend="italic">Beowulf2</hi> and <hi rend="italic">Beowulf6</hi>). </s></p><p n="p6.61"><s n="s1.1;p6.61">Below is a schema which explain the architecture of the three servers, </s></p><figure id="BAWE_3052e-fig.001"/><p n="p7.61"><s n="s1.2;p7.61">The root server file and the server file is the same. </s><s n="s2.2;p7.61">When the root server spawn the two others, it will add an argument called <hi rend="italic">"noroot"</hi> in order to inform the new process (Server1 and Server2) that they are not root, only simple server. </s></p><p n="p8.61"><s n="s1.3;p8.61">Of course, each server has to know the TID of each others in order to communicate together. </s><s n="s2.3;p8.61">So, after spawning the server, each server calls a synchronisation function which the aim is to send some information from the root server to the others servers. </s><s n="s3.3;p8.61">Then the servers TIDs are sent as well as the LockManager TID. </s></p><p n="p9.61"><s n="s1.1;p9.61">Hence, each server knows the TID of each others and the LockManager TID, so they are able to communicate together. </s></p><p n="p10.61"><s n="s1.1;p10.61">Server source file is <hi rend="italic">Server.c</hi>. </s></p></div2><div2><head rend="italic">The bidders:</head><p n="p11.61"><s n="s1.3;p11.61">The bidders can do five different things. </s><s n="s2.3;p11.61">First of all, they can register with the server (any server). </s><s n="s3.3;p11.61">Then can also see every auction contained in the server, they can bind for an auction, show the auction which they have won and can see the current time (on the server). </s></p><p n="p12.61"><s n="s1.7;p12.61">Before communicate with the server, the bidder has to connect with one of the server (a server which is available). </s><s n="s2.7;p12.61">This is done in 2 steps. </s><s n="s3.7;p12.61">First of all the bidder send a connection request through a socket to the root server (which IP address is determined: <hi rend="italic">10.0.1.4</hi>). </s><s n="s4.7;p12.61">This socket request is treated by the child process which is called <hi rend="italic">ListenOutside</hi> (in the schema above). </s><s n="s5.7;p12.61">The function name is <hi rend="italic">AcceptConnectionFromOutside</hi> in the root server (function called by the child process). </s><s n="s6.7;p12.61">Then every server TID are sent to the bidder and then the socket connection closes. </s><s n="s7.7;p12.61">Knowing the TIDs, the bidder is able to communicate with the server using PVM. </s></p><p n="p13.61"><s n="s1.3;p13.61">Afterward the bidder has to find an available server. </s><s n="s2.3;p13.61">When this server in found, the bidder is able to communicate with only this server. </s><s n="s3.3;p13.61">More details about the connection and message passing are written in another part below (section 3.). </s></p></div2><div2><head rend="italic">The sellers:</head><p n="p14.61"><s n="s1.3;p14.61">Bidder and seller architecture are very similar. </s><s n="s2.3;p14.61">The communication with the server is the same (connection, then find an available server, then communicate with this server). </s><s n="s3.3;p14.61">However, a seller can do only 3 things: register with the server, add an auction and see the result of its auctions. </s></p></div2></div1><div1 type="section"><head rend="bold italic">The data structures:</head><p n="p15.61"><s n="s1.2;p15.61">A file which is called <hi rend="italic">"structure.h"</hi> defines the data structure. </s><s n="s2.2;p15.61">These structures are used to store a seller, a bidder and an auction. </s></p><p rend="ordered" n="p16.61"><s n="s1.1;p16.61">Here is the structure which defines an auction, </s></p><p n="p17.61"><s n="s1.1;p17.61"><formula notation="" id="BAWE_3052e-form.001"/> </s></p><p rend="ordered" n="p18.61"><s n="s1.1;p18.61">Here is the structure which defines a seller, </s></p><p n="p19.61"><s n="s1.1;p19.61"><formula notation="" id="BAWE_3052e-form.002"/> </s></p><p rend="ordered" n="p20.61"><s n="s1.1;p20.61">Here is the structure which defines a bidder, </s></p><p n="p21.61"><s n="s1.1;p21.61"><formula notation="" id="BAWE_3052e-form.003"/> </s></p><p n="p22.61"><s n="s1.6;p22.61">A list of each of these structures is defined in the server file. </s><s n="s2.6;p22.61">These lists have to be always the same on the three servers! </s><s n="s3.6;p22.61">Indeed, for example, if a server treated a new seller, it has to inform the two other servers that a new seller is created. </s><s n="s4.6;p22.61">Furthermore, a mutual exclusion on each of these lists has to be managed. </s><s n="s5.6;p22.61">So, a LockManager is created and manages it. </s><s n="s6.6;p22.61">This is explain below, in another part. </s></p></div1><div1 type="section"><head rend="bold italic">Communication between the servers:</head><div2><head rend="italic">The main function in the server:</head><p n="p23.61"><s n="s1.4;p23.61">When the server is ready, it calls a function which has to receive an instruction (from another server or bidder or seller) which is sent via PVM with the tag number 1. </s><s n="s2.4;p23.61">Indeed, as we will see in all this report, when a PVM message is sent, a tag is used in order to make clear the reception buffer. </s><s n="s3.4;p23.61">So when a process waits for a message, it waits for a message which is tagged by a special number. </s><s n="s4.4;p23.61">This number is very useful to know what we have to do with this message. </s></p><p n="p24.61"><s n="s1.3;p24.61">So, the server waits for a message which is tagged by the number 1. </s><s n="s2.3;p24.61">This message is an instruction. </s><s n="s3.3;p24.61">When a message tagged by 1 is received, the server treats it. </s></p><p n="p25.61"><s n="s1.1;p25.61">Here is the list of all the instruction which can be treated by the server: </s></p><list type="ordered"><item><hi rend="italic">"testtime"</hi>: instruction which is received when the clock has to be synchronised</item><item><hi rend="italic">"newSeller"</hi>: instruction which is sent by a seller in order to register a new seller</item><item><hi rend="italic">"newBidder"</hi>: instruction which is sent by a bidder in order to register a new bidder</item><item><hi rend="italic">" newAuction"</hi>: instruction which is sent by a seller in order to add a new auction</item><item><hi rend="italic">"showmyauction"</hi>: instruction which is sent by a seller in order to show its auction</item><item><hi rend="italic">"showallauction"</hi>: instruction which is sent by a bidder in order to show every auction</item><item><hi rend="italic">"showAuctionWon"</hi>: instruction which is sent by a bidder in order to show which auction he has won</item><item><hi rend="italic">"whattimeisit"</hi>: instruction which is sent by a bidder in order to show the current time</item><item><hi rend="italic">"newBid"</hi>: instruction which is sent by a bidder in order to send a new bid</item><item><hi rend="italic">"areyouavble"</hi>: means "are you available". This instruction is used to ask to a server if it is available</item><item><hi rend="italic">"syncsellerlist"</hi>: instruction which is sent by a server to the others servers in order to synchronise the seller list resource</item><item><hi rend="italic">"syncauctionlist"</hi>: instruction which is sent by a server to the others servers in order to synchronise the auction list resource</item><item><hi rend="italic">"syncbidderlist"</hi>: instruction which is sent by a server to the others servers in order to synchronise the bidder list resource</item></list><p n="p26.61"><s n="s1.2;p26.61">Some of these instructions are detailed in this report. </s><s n="s2.2;p26.61">So, each time the server receives one of these instructions, it will treat it by following is protocol. </s></p></div2><div2><head rend="italic">The clock synchronisation:</head><p n="p27.61"><s n="s1.6;p27.61">As we said above, the clock synchronisation is managed by a child process which knows the TIDs of every server (except its parent). </s><s n="s2.6;p27.61">This process synchronises the server clock by sending a PVM message to every server except its parents. </s><s n="s3.6;p27.61">Indeed, synchronise its parent is not necessary because they runs on the same machine, so the current time is the same. </s><s n="s4.6;p27.61">The delay between every clock synchronisation is defined by <hi rend="italic">#define CLOCK_SYNC_TIME_SET 10</hi>. </s><s n="s5.6;p27.61">This is in second. </s><s n="s6.6;p27.61">Here, it is 10 second. </s></p><p n="p28.61"><s n="s1.4;p28.61">As we know, an auction has to be terminated after a time which is determined by the seller (which starts the auction). </s><s n="s2.4;p28.61">Hence, each auction's duration has to be checked every <hi rend="italic">CLOCK_SYNC_TIME_SET</hi> seconds. </s><s n="s3.4;p28.61">So, one of the server has to do that when it receives the clock synchronisation. </s><s n="s4.4;p28.61">If an auction is finished, it has to close it. </s></p><p n="p29.61"><s n="s1.1;p29.61">Below is the clock synchronisation sequence diagram which explains how it works, </s></p><figure id="BAWE_3052e-fig.002"/><p n="p30.61"><s n="s1.2;p30.61">So, the two others servers receive the current time then save it in a global variable and one of the servers receives an instruction in order to update each auction's duration. </s><s n="s2.2;p30.61">This update decreases the auction's duration (-1). </s></p><p n="p31.61"><s n="s1.2;p31.61">So, when a seller define the duration of a new auction, he will enter a number which is the number of minutes (in the real life, <hi rend="italic">CLOCK_SYNC_TIME_SET</hi> would be equal to 60) and so, every minutes, the duration is decreased. </s><s n="s2.2;p31.61">However, in order to test the program, <hi rend="italic">CLOCK_SYNC_TIME_SET</hi> is equal to 10. </s></p></div2><div2><head rend="italic">The data synchronisation:</head><p n="p32.61"><s n="s1.6;p32.61">As we said above, each data list (seller, bidder and auction) has to be the same on each server. </s><s n="s2.6;p32.61">So, after a server has modified one of these lists, it has to inform the others servers. </s><s n="s3.6;p32.61">Furthermore, in order to stay coherent, a list can be accessed by ONLY ONE server in the same time. </s><s n="s4.6;p32.61">Indeed, if a server modifies a list and another server modifies the same list in the same time, they will inform each other but one of the information will be lost. </s><s n="s5.6;p32.61">So, a mutual exclusion has to be defined. </s><s n="s6.6;p32.61">Hence, a LockManager manages it. </s></p><p n="p33.61"><s n="s1.2;p33.61">Every time a server wants to access to a resource (one of the three lists: seller, bidder and auction), it has to ask to the LockManager if it is allowed to access to this resource. </s><s n="s2.2;p33.61">Then if that is the case, when the server has finished with this resource, it has to inform the LockManager in order to free this resource and then, the server inform the others servers in order to synchronise the list data. </s></p><p n="p34.61"><s n="s1.1;p34.61">For example, a resource access looks like below, </s></p><p n="p35.61"><s n="s1.1;p35.61"><formula notation="" id="BAWE_3052e-form.004"/> </s></p><div3><head rend="italic">The Lock Manager:</head><p n="p36.61"><s n="s1.10;p36.61">When <hi rend="italic">mutex_enter</hi> is called, the lock manager is informed that a server wants to access to a resource. </s><s n="s2.10;p36.61">If this resource is free then the server can use it. </s><s n="s3.10;p36.61">Otherwise, the server is blocked and waits for the release of this resource. </s><s n="s4.10;p36.61">Actually, the server waits for a synchronisation. </s><s n="s5.10;p36.61">Indeed, if the resource is not free, that means a second server is using it. </s><s n="s6.10;p36.61">So, this second server will free it and then a synchronisation will be done. </s><s n="s7.10;p36.61">Afterward, the server will ask again to the LockManager if the resource is free and the answer would be positive. </s><s n="s8.10;p36.61">If two servers want to access in the same resource which is not free then they will be blocked and they will wait for the data synchronisation. </s><s n="s9.10;p36.61">Afterward, they will ask to the LockManager if the resource is free, but only one server (the first one, this is determined by chance) would be able to use it. </s><s n="s10.10;p36.61">The other one will be blocked again until the next data synchronisation. </s></p><p n="p37.61"><s n="s1.2;p37.61">The sequence diagram below explain the case where the resource is available. </s><s n="s2.2;p37.61">On this diagram, the resource needed is called <hi rend="italic">"this resource"</hi>, </s></p><figure id="BAWE_3052e-fig.003"/><p n="p38.61"><s n="s1.1;p38.61">We don't draw the sequence diagram for the case where the resource is not available, but it's a bit similar and we can guess it easily. </s></p><p n="p39.61"><s n="s1.1;p39.61">So, the mutual is done by three functions: <hi rend="italic">LockManager</hi> (a child process manages it), <hi rend="italic">mutex_enter</hi> and <hi rend="italic">mutex_exit</hi>. </s></p></div3><div3><head rend="italic">The mutex_enter/exit functions:</head><p n="p40.61"><s n="s1.1;p40.61">In order to understand how <hi rend="italic">mutex_enter</hi> and <hi rend="italic">mutex_exit</hi> work, below is the code (not all the code, only the pseudo code), </s></p><p n="p41.61"><s n="s1.1;p41.61"><formula notation="" id="BAWE_3052e-form.005"/> </s></p><p n="p42.61"><s n="s1.1;p42.61">Hence, each resource is accessed by only one server in the same time and when a resource is modified by a server, the others are informed about it before to use it themselves. </s></p></div3></div2></div1><div1 type="section"><head rend="bold italic">Communication between the server and outside (seller/bidder):</head><div2><head rend="italic">Connection to a server:</head><p n="p43.61"><s n="s1.4;p43.61">As we have explained above, the seller or bidder send a connection request (via a socket) and then receives the TIDs of every server. </s><s n="s2.4;p43.61">Afterward, it has to find an available server. </s><s n="s3.4;p43.61">In order to manage it, the bidder/seller sends an instruction which is called <hi rend="italic">"areyouavble"</hi> to the first server. </s><s n="s4.4;p43.61">This instruction means "Are you available" ? </s></p><p n="p44.61"><s n="s1.2;p44.61">If the server is available, that means it can receive this instruction and so, can answer. </s><s n="s2.2;p44.61">Hence, if the seller/bidder receives an answer from this server, then this server is available and then the seller/bidder will communicate with this one. </s></p><p n="p45.61"><s n="s1.4;p45.61">If the server is not available, then it won't answer and after 1 second, the seller/bidder will send the same request to another server, because that means the first one is not available. </s><s n="s2.4;p45.61">If the second server is not available, the seller/bidder will ask to the last one. </s><s n="s3.4;p45.61">If the three are not available, then the seller/bidder informs the user. </s><s n="s4.4;p45.61">So, if a response is not received from a server after 1 second that means the server is not available and we have to try with another server. </s></p><p n="p46.61"><s n="s1.1;p46.61">The instruction <hi rend="italic">"areyouavble"</hi> is send with the tag 1 (we explained above the reason). </s></p><p n="p47.61"><s n="s1.1;p47.61">The schema below explains this process to find an available server, </s></p><figure id="BAWE_3052e-fig.004"/></div2><div2><head rend="italic">General communication with a server:</head><p n="p48.61"><s n="s1.2;p48.61">The bidder/seller need to communicate with the server in order to have or send some information (for example, new bidder, new seller etc...). </s><s n="s2.2;p48.61">Here are explained some of possible communication. </s></p><div3><head rend="italic">Bidder / Server:</head><p rend="bulleted" n="p49.61"><s rend="italic" n="s1.1;p49.61">New Bidder: </s></p><p n="p50.61"><s n="s1.3;p50.61">Here is the sequence diagram useful for the creation of a new bidder. </s><s n="s2.3;p50.61">This sequence diagram is the same for the creation of a new seller. </s><s n="s3.3;p50.61">However, the tag message used for the bidder is the number 18 (use for every transaction used to create a bidder) and the number used for the seller is 16 (for all the transaction used to create a seller). </s></p><p n="p51.61"><s n="s1.2;p51.61">In this diagram sequence, we can see the User. </s><s n="s2.2;p51.61">We show it only in this sequence diagram because it is not very important for the explanation, </s></p><figure id="BAWE_3052e-fig.005"/><p rend="bulleted" n="p52.61"><s rend="italic" n="s1.1;p52.61">Bid for an auction: </s></p><p n="p53.61"><s n="s1.1;p53.61">Here is the diagram used when a bidder wants to bid for an auction, </s></p><figure id="BAWE_3052e-fig.006"/><p rend="bulleted" n="p54.61"><s rend="italic" n="s1.1;p54.61">Add and start an auction (a seller do that): </s></p><p n="p55.61"><s n="s1.1;p55.61">Here is the diagram sequence used when a seller wants to add and start a new auction, </s></p><p n="p56.61"><s rend="italic" n="s1.1;p56.61">(please see next page) </s></p><figure id="BAWE_3052e-fig.007"/><p n="p57.61"><s n="s1.3;p57.61">In these diagrams, we can see some intern action like "Add auction". </s><s n="s2.3;p57.61">Of course, these intern actions are complexes. </s><s n="s3.3;p57.61">They use the mutual exclusion to access to the different data, synchronise the data list with the others servers etc... </s></p><p n="p58.61"><s n="s1.1;p58.61">The others sequence diagrams (show auctions, show time etc...) are not shown here. </s></p></div3></div2></div1><div1 type="section"><head rend="bold italic">Critique of the code:</head><p n="p59.61"><s n="s1.4;p59.61">This program doesn't manage the case where a server dies. </s><s n="s2.4;p59.61">Indeed, if a server dies, the system still works (with only 2 servers) but the dead server doesn't become alive again. </s><s n="s3.4;p59.61">If the root server dies, the child process (clock synchronisation and accept connection from outside) would still work, so the root server dead is not a problem. </s><s n="s4.4;p59.61">However, if one of the two other server (the second one, on Beowulf6) dies, the system can't work again because this server has to manage the auction's duration (see above). </s></p><p n="p60.61"><s n="s1.3;p60.61">So, I think the system depends to much on the reliability of the server. </s><s n="s2.3;p60.61">If one dies, some problem can occur and if the one on Beowulf6 dies, the system dies as well. </s><s n="s3.3;p60.61">So, that's a problem in this program. </s></p></div1><div1 type="section"><head rend="bold italic">Comparison with a real world system:</head><p n="p61.61"><s n="s1.2;p61.61">A real world system like ebay.com can stay alive if one of the servers dies. </s><s n="s2.2;p61.61">Furthermore, in general, more than 3 servers are available in a real system. </s></p></div1></body><back/></text></TEI.2>
