<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_6056a" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>Algorithms Coursework I - Stacks</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">Page header contains: module title; assignment title. 
Page footer contains: page number; student name. 
</note></notesStmt><sourceDesc><p n="level">1</p><p n="date">2005-03</p><p n="module title">Introduction to Algorithms</p><p n="module code">CS1G2</p><p n="genre family">Design specification</p><p n="discipline">Computer Science</p><p n="disciplinary group">PS</p><p n="grade">M</p><p n="number of authors">1</p><p n="number of words">866</p><p n="number of s-units">44</p><p n="number of p">11</p><p n="number of tables">1</p><p n="number of figures">2</p><p n="number of block quotes">0</p><p n="number of formulae">1</p><p n="number of lists">0</p><p n="number of paragraphs formatted like lists">0</p><p n="abstract present">no abstract</p><p n="average words per s-unit">19.7</p><p n="average s-units per p">4.0</p><p n="macrotype of assignment">simple assignment</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">m</p><p n="year of birth">1986</p><p n="first language">English</p><p n="education">UKa</p><p n="course">Electronic Engineering and Cybernetics</p><p n="student ID">6056</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><docTitle><titlePart rend="underlined bold">Algorithms Coursework I - Stacks</titlePart></docTitle></titlePage></front><body><div1 type="section"><head rend="underlined bold">Introduction</head><p n="p1.11"><s n="s1.2;p1.11">This program is required to do two things; convert infix equations, where the operators are in between operands, to postfix, where the operators come after the operands, also to evaluate the postfix expression and come up with an answer. </s><s n="s2.2;p1.11">The program will use a stack data structure and will read the expression from an edit box, where the user shall type in the expression. </s></p></div1><div1 type="section"><head rend="underlined bold">Design and Implementation</head><div2><head rend="underlined bold">Data Structure</head><p n="p2.11"><s n="s1.5;p2.11">The data structure is defined as a stack. </s><s n="s2.5;p2.11">This means that the items are stored in a list and can only be read from and added to at the top of the list. </s><s n="s3.5;p2.11">This structure is best design with pointers. </s><s n="s4.5;p2.11">So a pointer of type stack is needed, where stack is a record with one part being the data being held and the other is a pointer to the next item in the list. </s><s n="s5.5;p2.11">With this a few functions are need; Pop, Push, IsEmpty, MakeEmpty, Readtop and Display. </s></p><p n="p3.11"><s n="s1.6;p3.11">Pop is used to remove the top item of data from the list, not before storing the data from this element for use. </s><s n="s2.6;p3.11">Push will insert a new element with new data at the top of the list. </s><s n="s3.6;p3.11">IsEmpty will simply see if the top pointer is pointing at nil, which if it is will indicate the list is empty. </s><s n="s4.6;p3.11">MakeEmpty will remove all items from the list and dispose of all the memory leaving just the top pointer pointing at nil. </s><s n="s5.6;p3.11">Readtop is similar to pop with the exception that it does not remove the memory, it simply reads the data from the top element. </s><s n="s6.6;p3.11">Display will display all of the list's elements in a string. </s></p></div2><div2><head rend="underlined bold">Evaluate Postfix</head><p n="p4.11"><s n="s1.2;p4.11">This procedure is needed to read an expression written in the postfix form and solve it. </s><s n="s2.2;p4.11">Evaluating postfix would need to read through the equation, storing digits in the stack, until an operator is discovered when it will be evaluated with the next two numbers in the stack. </s></p><p n="p5.11"><s n="s1.5;p5.11">To achieve these desired results a case statement is used to look for certain characters. </s><s n="s2.5;p5.11">For the digits 0-9 the real number is pushed onto the stack for use later on. </s><s n="s3.5;p5.11">When it comes to an operator, all the code says to do is pop the top two elements in the stack and then run the evaluate function, already declared in the program, using the operator read in. </s><s n="s4.5;p5.11">The result of this is then pushed onto the stack. </s><s n="s5.5;p5.11">If there are no more operators then this will be the answer printed out, else it will be used with operators later on in the equation. </s></p></div2><div2><head rend="underlined bold">Infix to Postfix</head><p n="p6.11"><s n="s1.3;p6.11">To solve the problem of infix to postfix would involve reading the equation typed in, written in infix form, and rearranging the layout. </s><s n="s2.3;p6.11">This means that a check of each character would be needed, with digits 0 to 9 being put into a string and the operators being pushed onto a stack until needed. </s><s n="s3.3;p6.11">The other problem of priority can be overcome by using the priority function already declared in the program. </s></p><p n="p7.11"><s n="s1.11;p7.11">Implementing this code involves a case statement for each digit that could potentially occur. </s><s n="s2.11;p7.11">Digits 0 to 9 are added to a string as they come up. </s><s n="s3.11;p7.11">For the operators, they involved nested If and Case statements. </s><s n="s4.11;p7.11">These are all part of the checking procedure to see whether the stack is empty, the top element in the stack is of a higher priority or if a left bracket has occurred. </s><s n="s5.11;p7.11">After the checks, there is some similar code. </s><s n="s6.11;p7.11">With nothing in the stack the operator will be pushed straight on. </s><s n="s7.11;p7.11">However when there is an operator already in the stack the priorities are compared, if the operator in the stack is higher priority or the same, then it is popped and added to the string then the other operator is pushed onto the stack. </s><s n="s8.11;p7.11">Otherwise the operator is pushed onto the stack and then the next character is checked. </s><s n="s9.11;p7.11">When a left bracket occurs it is pushed into the stack as a marker. </s><s n="s10.11;p7.11">The right bracket, when read in runs code that will pop the stack into the string until a marker is found or the stack is empty. </s><s n="s11.11;p7.11">With all of this the concepts of operator priority, use of brackets and converting to correct postfix notation is achieved. </s></p></div2><div2><head rend="underlined bold">Testing</head><p n="p8.11"><s n="s1.5;p8.11">To test these procedures, I will first try very simple equations. </s><s n="s2.5;p8.11">Then once it solves these correctly I will then advance onto slightly more complex equations until eventually I will have an equation with multiple brackets and several different operators. </s><s n="s3.5;p8.11">At each stage, should the conversion or evaluation not run correctly, I shall implement alterations to the code when needed. </s><s n="s4.5;p8.11">This same theory of testing can be applied to both infix to postfix and evaluating postfix. </s><s n="s5.5;p8.11">As the infix equation becomes more complicated so too will the postfix to be evaluated. </s></p><p n="p9.11"><s n="s1.2;p9.11">Below is a table comprising of the equation used, the postfix conversion and the evaluated postfix. </s><s n="s2.2;p9.11">These are printed in the order of testing. </s></p><table id="BAWE_6056a-tab.001"><row><cell/></row></table><p n="p10.11"><s n="s1.2;p10.11">As seen here the equations typed in got progressively more complex and began to introduce new components such as brackets and power. </s><s n="s2.2;p10.11">Following are a couple of screenshots showing what is seen when the procedures are executed. </s></p><figure id="BAWE_6056a-pic.001"/><figure id="BAWE_6056a-pic.002"/><p n="p11.11"><s n="s1.1;p11.11"><formula notation="" id="BAWE_6056a-form.001"/> </s></p></div2></div1></body><back/></text></TEI.2>
