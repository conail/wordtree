<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_6101e" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>[Assessed Assignment 1 - Number Theory]</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">Page header contains: student name. 
Page footer contains: page number. </note><note resp="British Academic Written English (BAWE) corpus project">Evaluated as candidate compound assignment. Assigned to A3c: set of exercises + reflection: non-compound.
 
</note></notesStmt><sourceDesc><p n="level">1</p><p n="date">2003-11</p><p n="module title">Functional Programming</p><p n="module code">CS1H2</p><p n="genre family">Exercise</p><p n="discipline">Computer Science</p><p n="disciplinary group">PS</p><p n="grade">D</p><p n="number of authors">1</p><p n="number of words">1135</p><p n="number of s-units">81</p><p n="number of p">49</p><p n="number of tables">0</p><p n="number of figures">0</p><p n="number of block quotes">0</p><p n="number of formulae">16</p><p n="number of lists">0</p><p n="number of paragraphs formatted like lists">0</p><p n="abstract present">no abstract</p><p n="average words per s-unit">14.0</p><p n="average s-units per p">1.7</p><p n="macrotype of assignment">complex but non-compound assignment (see notesStmt for details)</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">m</p><p n="year of birth">1984</p><p n="first language">English</p><p n="education">UKa</p><p n="course">Computer Science</p><p n="student ID">6101</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><docTitle><titlePart rend="bold">Assessed Assignment 1 - Number Theory</titlePart></docTitle></titlePage></front><body><div1 type="section"><head rend="underlined bold">Question 1</head><div2><head rend="bold">Aim </head><p n="p1.49"><s n="s1.1;p1.49">To define a function that returns the maximum of three numbers. </s></p></div2><div2><head rend="bold italic">Version 1</head><div3><head rend="underlined">Code</head><p n="p2.49"><s n="s1.1;p2.49"><formula notation="" id="BAWE_6101e-form.001"/> </s></p></div3><div3><head rend="underlined">Explanation</head><p n="p3.49"><s n="s1.1;p3.49">The function max3 is defined as having 3 arguments - a, b, and c. </s></p><p n="p4.49"><s n="s1.1;p4.49">If a is the largest, then return a. </s></p><p n="p5.49"><s n="s1.1;p5.49">If b is the largest, then return b. </s></p><p n="p6.49"><s n="s1.1;p6.49">If c is the largest, then return c. </s></p><p n="p7.49"><s n="s1.1;p7.49">In the case of error, return 0. </s></p></div3><div3><head rend="underlined">Test</head><p n="p8.49"><s n="s1.1;p8.49"><formula notation="" id="BAWE_6101e-form.002"/> </s></p></div3><div3><head rend="underlined">Conclusions</head><p n="p9.49"><s n="s1.3;p9.49">Although the first three tests were successful, the fourth was not. </s><s n="s2.3;p9.49">The reason for this was that when using the strictly greater than sign, neither of the threes is the maximum. </s><s n="s3.3;p9.49">We can correct this by making the signs greater than or equal to. </s></p></div3></div2><div2><head rend="bold italic">Version 2</head><div3><head rend="underlined">Code</head><p n="p10.49"><s n="s1.1;p10.49"><formula notation="" id="BAWE_6101e-form.003"/> </s></p></div3><div3><head rend="underlined">Test</head><p n="p11.49"><s n="s1.1;p11.49"><formula notation="" id="BAWE_6101e-form.004"/> </s></p></div3><div3><head rend="underlined">Conclusion</head><p n="p12.49"><s n="s1.1;p12.49">This function now performs its task correctly. </s></p></div3></div2></div1><div1 type="section"><head rend="underlined bold">Question 2</head><div2><head rend="bold">Aim</head><p n="p13.49"><s n="s1.1;p13.49">To create a recursive function that uses Euclid's algorithm to find the greatest common divisor (GCD) of three positive integers. </s></p></div2><div2><head rend="bold italic">Version 1</head><div3><head rend="underlined">Code</head><p n="p14.49"><s n="s1.1;p14.49"><formula notation="" id="BAWE_6101e-form.005"/> </s></p></div3><div3><head rend="underlined">Explanation</head><p n="p15.49"><s n="s1.5;p15.49">Euclid's algorithm is based on the fact that GCD(a,b) = GCD(b,r) where r is the remainder of <hi rend="italic">a</hi> and <hi rend="italic">b</hi>. </s><s n="s2.5;p15.49">This means that you can create iterations whereby <hi rend="italic">a</hi> becomes <hi rend="italic">b</hi> and <hi rend="italic">b</hi> becomes <hi rend="italic">r</hi> until <hi rend="italic">b</hi> hits 0. </s><s n="s3.5;p15.49">The recurring function I created tests to see whether <hi rend="italic">b</hi> has reached 0. </s><s n="s4.5;p15.49">If it has, it returns <hi rend="italic">a</hi>, which is the GCD. If it has not, it recurs the function with <hi rend="italic">b</hi> and the remainder of <hi rend="italic">a</hi> and <hi rend="italic">b</hi>. </s><s n="s5.5;p15.49">This will not create an infinite loop as Euclid proved that b will reach 0 in a finite number of iterations. </s></p></div3><div3><head rend="underlined">Test</head><p n="p16.49"><s n="s1.1;p16.49"><formula notation="" id="BAWE_6101e-form.006"/> </s></p></div3><div3><head rend="underlined">Conclusion</head><p n="p17.49"><s n="s1.1;p17.49">This function performs its task correctly. </s></p></div3></div2><div2><head rend="bold italic">Version 2</head><div3><head rend="underlined">Code</head><p n="p18.49"><s n="s1.1;p18.49"><formula notation="" id="BAWE_6101e-form.007"/> </s></p></div3><div3><head rend="underlined">Test</head><p n="p19.49"><s n="s1.1;p19.49"><formula notation="" id="BAWE_6101e-form.008"/> </s></p></div3><div3><head rend="underlined">Conclusion</head><p n="p20.49"><s n="s1.1;p20.49">This function performs its task correctly. </s></p></div3></div2></div1><div1 type="section"><head rend="underlined bold">Question 3</head><div2><head rend="bold">Aim</head><p n="p21.49"><s n="s1.1;p21.49">To create a function to return the GCD of three integer arguments. </s></p></div2><div2><head rend="bold italic">Version 1</head><div3><head rend="underlined">Code</head><p n="p22.49"><s n="s1.1;p22.49"><formula notation="" id="BAWE_6101e-form.009"/> </s></p></div3><div3><head rend="underlined">Explanation</head><p n="p23.49"><s n="s1.2;p23.49">The min3 function is as the max3 function in question 1, but with the signs reversed. </s><s n="s2.2;p23.49">It is needed for the gcd3 function. </s></p><p n="p24.49"><s n="s1.2;p24.49">The gcd function is called initially. </s><s n="s2.2;p24.49">It checks that the three values are greater than 0, then finds the smallest of these three values and calls the function gcd3a with this value and the three initial arguments. </s></p><p n="p25.49"><s n="s1.4;p25.49">The recurring function gcd3a has four arguments. </s><s n="s2.4;p25.49">It has the three initial values that it will find the GCD of, and the divisor, <hi rend="italic">d</hi>. </s><s n="s3.4;p25.49">This variable <hi rend="italic">d</hi> will eventually contain the GCD. We know that this won't be larger than the smallest of the three integers, so it starts at the minimum of the three. </s><s n="s4.4;p25.49">If <hi rend="italic">d</hi> divides into all three integers with no remainder, then it is the true GCD. If it doesn't then it recalls the function with <hi rend="italic">d</hi> decreased by 1. </s></p><p n="p26.49"><s n="s1.1;p26.49">It will not enter into an infinite loop as when d hits 1 it will divide into the other three integers with no remainder whatever they are. </s></p><p n="p27.49"><s n="s1.1;p27.49"><hi rend="italic">d</hi> will approach 1 as it has to be greater or equal to 1 initially because the numbers that it is the minimum of are. </s></p></div3><div3><head rend="underlined">Test</head><p n="p28.49"><s n="s1.1;p28.49"><formula notation="" id="BAWE_6101e-form.010"/> </s></p></div3><div3><head rend="underlined">Conclusion</head><p n="p29.49"><s n="s1.1;p29.49">This function performs its task correctly. </s></p></div3></div2></div1><div1 type="section"><head rend="underlined bold">Question 4</head><div2><head rend="bold">Aim</head><p n="p30.49"><s n="s1.1;p30.49">To create a function that returns whether or not a given integer is prime. </s></p></div2><div2><head rend="bold italic">Version 1 </head><div3><head rend="underlined">Code</head><p n="p31.49"><s n="s1.1;p31.49"><formula notation="" id="BAWE_6101e-form.011"/> </s></p></div3><div3><head rend="underlined">Explanation</head><p n="p32.49"><s n="s1.2;p32.49">The non-recurring function 'prime' is called first. </s><s n="s2.2;p32.49">This has one parameter, <hi rend="italic">x</hi>, which is the integer that will be tested. </s></p><p n="p33.49"><s n="s1.3;p33.49">If <hi rend="italic">x</hi> is equal to 0, 1 or -1, it is not a prime number, so the function can return <hi rend="italic">false</hi>. </s><s n="s2.3;p33.49">If <hi rend="italic">x</hi> is negative, then the function prim1 will be called with negated (i.e. made positive) values of <hi rend="italic">x</hi>. </s><s n="s3.3;p33.49">If it is an integer that is greater than 1, prime1 is called with <hi rend="italic">x</hi>. </s></p><p n="p34.49"><s n="s1.6;p34.49">The recurring function prime1 has 2 parameters: <hi rend="italic">d</hi>, a temporary number that will decrease, and <hi rend="italic">x</hi>, the positive integer that is being tested. </s><s n="s2.6;p34.49">At the start, <hi rend="italic">d</hi> = <hi rend="italic">x</hi>. </s><s n="s3.6;p34.49">The function divides the <hi rend="italic">x</hi> by <hi rend="italic">d</hi>. </s><s n="s4.6;p34.49">If there is no remainder, then <hi rend="italic">x</hi> cannot be prime, so the value of <hi rend="italic">false</hi> is returned. </s><s n="s5.6;p34.49">If there is a remainder, then the process is run again with <hi rend="italic">d</hi> decreased by 1. </s><s n="s6.6;p34.49">If <hi rend="italic">d</hi> gets down to 2 without ever creating a zero remainder when <hi rend="italic">x</hi> is divided by it, then <hi rend="italic">x</hi> is a prime number and a value of <hi rend="italic">true</hi> is returned. </s></p><p n="p35.49"><s n="s1.2;p35.49">It will never enter an infinite loop, as d starts as a positive integer that is greater than 1 and decreases while it is greater than 2. </s><s n="s2.2;p35.49">This means that it must reach 2 in a finite number of iterations. </s></p></div3><div3><head rend="underlined">Test</head><p n="p36.49"><s n="s1.1;p36.49"><formula notation="" id="BAWE_6101e-form.012"/> </s></p></div3><div3><head rend="underlined">Conclusion</head><p n="p37.49"><s n="s1.1;p37.49">This function performs its task correctly. </s></p></div3></div2><div2><head rend="bold italic">Version 2 </head><div3><head rend="underlined">Code</head><p n="p38.49"><s n="s1.1;p38.49"><formula notation="" id="BAWE_6101e-form.013"/> </s></p></div3><div3><head rend="underlined">Test</head><p n="p39.49"><s n="s1.1;p39.49"><formula notation="" id="BAWE_6101e-form.014"/> </s></p></div3><div3><head rend="underlined">Conclusion</head><p n="p40.49"><s n="s1.6;p40.49">This function performs its task correctly. </s><s n="s2.6;p40.49">If you think about it, however, it is doing a lot more processing than it needs. </s><s n="s3.6;p40.49">If we enter "prime(16);;", it starts by seeing whether 15 will divide into 16, then 14 etc. </s><s n="s4.6;p40.49">In reality, there can be no integers that divide exactly into 16 that are above 16/2 = 8. </s><s n="s5.6;p40.49">Therefore, we only need do half the iterations. </s><s n="s6.6;p40.49">I will make a version 3 that takes this into account. </s></p></div3></div2><div2><head rend="bold italic">Version 3 </head><div3><head rend="underlined">Code</head><p n="p41.49"><s n="s1.1;p41.49"><formula notation="" id="BAWE_6101e-form.015"/> </s></p></div3><div3><head rend="underlined">Explanation</head><p n="p42.49"><s n="s1.5;p42.49">This is much as before, but with the divisor starting at half of <hi rend="italic">x</hi> rather than at <hi rend="italic">x</hi>. </s><s n="s2.5;p42.49">For more information see Version 2's conclusion. </s><s n="s3.5;p42.49">The other change that was implemented was that the specific case of when <hi rend="italic">x</hi> = 2, 3, -2 or -3 needed to be added as patterns. </s><s n="s4.5;p42.49">This is because using integer arithmetic; all four of these values halve to make 1 or - 1. </s><s n="s5.5;p42.49">If we were to let prime1 run with this it will see that <hi rend="italic">x</hi> divides into 1 and say that it isn't a prime number. </s></p></div3><div3><head rend="underlined">Test</head><p n="p43.49"><s n="s1.1;p43.49"><formula notation="" id="BAWE_6101e-form.016"/> </s></p></div3><div3><head rend="underlined">Conclusion</head><p n="p44.49"><s n="s1.1;p44.49">This function performs its task correctly. </s></p></div3></div2></div1><div1 type="section"><head rend="underlined bold">Self-Reflection Task</head><p n="p45.49"><s n="s1.2;p45.49">After writing all of the functions needed for this set of tasks, I had a lecture about patterns. </s><s n="s2.2;p45.49">I realised that a few of my functions could be neatened using these, so I have added a more concise second version to some of the working functions. </s></p><p n="p46.49"><s n="s1.2;p46.49">Through doing this work, I appreciate more fully how recurring functions as well as functional programming in general works. </s><s n="s2.2;p46.49">I have realised the importance of the order of the code - you can't refer to a function in a piece of code unless you've declared said function previously. </s></p><p n="p47.49"><s n="s1.2;p47.49">I also realised that when working with integers, it is necessary to think about integer arithmetic, for example that 3/2 = 1. </s><s n="s2.2;p47.49">This is something I'm not used to doing, so it comes as a bit of a shock. </s></p><p n="p48.49"><s n="s1.1;p48.49">I did encounter difficulties using Xemacs and Unix themselves; it took a while to get used to not performing copy and paste operations using MS Windows keyboard shortcuts, and it was odd not having the CTRL-ALT-DEL option when it crashed. </s></p><p n="p49.49"><s n="s1.1;p49.49">As an afterthought, the prime number function in question 4 could be made even more economical by using the square root of <hi rend="italic">x</hi> as the initial value of <hi rend="italic">d</hi>, rather than <hi rend="italic">x</hi> / 2. </s></p></div1></body><back/></text></TEI.2>
