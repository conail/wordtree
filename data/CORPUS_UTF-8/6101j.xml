<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_6101j" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>CS3Q2 - Computer Science Interim Report. Package for Electronic Mapping - PDA Version</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">The document has a title page which contains:
document title
title part</note><note resp="British Academic Written English (BAWE) corpus project">Page header contains: student name; supervisor; module code + title. 
Page footer contains: page number. 
</note></notesStmt><sourceDesc><p n="level">3</p><p n="date">2006-04</p><p n="module title">Final Year Project</p><p n="module code">CS3Q2</p><p n="genre family">Design specification</p><p n="discipline">Computer Science</p><p n="disciplinary group">PS</p><p n="grade">D</p><p n="number of authors">1</p><p n="number of words">2285</p><p n="number of s-units">83</p><p n="number of p">39</p><p n="number of tables">2</p><p n="number of figures">5</p><p n="number of block quotes">0</p><p n="number of formulae">0</p><p n="number of lists">2</p><p n="number of paragraphs formatted like lists">0</p><p n="abstract present">abstract present</p><p n="average words per s-unit">27.5</p><p n="average s-units per p">2.1</p><p n="macrotype of assignment">simple assignment</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">m</p><p n="year of birth">1984</p><p n="first language">English</p><p n="education">UKa</p><p n="course">Computer Science</p><p n="student ID">6101</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><titlePart><hi rend="bold"><name type="university"/> Department of Computer Science</hi><hi rend="bold"> School of Systems Engineering</hi></titlePart><docTitle><titlePart rend="bold">CS3Q2 - Computer Science Interim Report Package for Electronic Mapping - PDA Version</titlePart></docTitle><titlePart><hi rend="bold"><name type="student name"/> Supervised by <name type="tutor name"/></hi><hi rend="bold"> 6th January 2006</hi></titlePart></titlePage></front><body><div1 type="abstract"><head rend="bold">Abstract</head><p n="p1.39"><s n="s1.2;p1.39">The principle aim of the project is to develop a PDA application with which a user can see information regarding the geography of the area they are in. </s><s n="s2.2;p1.39">More specifically, the project will focus on displaying an accurate drawing of the skyline and labelling any hills that feature. </s></p><p n="p2.39"><s n="s1.1;p2.39">Alongside the PDA application there will be a PC application, with which the user can select the area that they intend to use the PDA in, and have the relevant data made available to the PDA. </s></p><p n="p3.39"><s n="s1.1;p3.39">This interim report is to discuss progress made thus far, and also to amend and create plans for the remainder of the project period. </s></p></div1><div1 type="front-back-matter"><head rend="bold">Contents</head><p/></div1><div1 type="section"><head rend="bold">Introduction to the Project and Specification</head><p n="p4.39"><s n="s1.2;p4.39">There exist programs for viewing maps in 3D on a computer. </s><s n="s2.2;p4.39">Examples are Google Earth [1], ESRI ArcGIS [2], and Memory-Map [3]. </s></p><figure id="BAWE_6101j-pic.001"><head rend="italic">Google Earth showing Grand Canyon, © 2006 Google</head></figure><figure id="BAWE_6101j-pic.002"><head rend="italic">Memory-Map's view from the Lake District, © 2006 Memory-Map</head></figure><p n="p5.39"><s n="s1.1;p5.39">There also exist programs for viewing maps and geographic features on a PDA. Examples are ESRI ArcPad [4] and Mobile Memory Map [3]. </s></p><figure id="BAWE_6101j-pic.003"><head rend="italic">Memory-Map in operation, © 2006 Memory-Map</head></figure><figure id="BAWE_6101j-pic.004"><head rend="italic">ArcPad screen shot, © 2006 ESRI</head></figure><p n="p6.39"><s n="s1.2;p6.39">Both of these examples, and indeed all other existing products I have looked at, will only show the world in plan, as a map. </s><s n="s2.2;p6.39">My project, therefore, is to do what, it seems, has not been done, and combine the two by showing geographic data on a PDA that is not in plan. </s></p><p n="p7.39"><s n="s1.3;p7.39">When the user enters their co-ordinates, the system will draw the horizon, and label all the hills. </s><s n="s2.3;p7.39">The user will have an easy interface so that they can scroll through the horizon. </s><s n="s3.3;p7.39">They will also be able to get other information, for example their current height, or the height of a particular mountain they can see. </s></p><p n="p8.39"><s n="s1.1;p8.39">There will be a supporting PC application which will allow the user to choose what data is supplied to the PDA, as well as having extra functionality, for example displaying the horizon for any given point. </s></p><p n="p9.39"><s n="s1.1;p9.39">The user will also be able to define markers, for example their route's start point or the place they intend to have lunch, which will feature in the horizon on the PDA whether or not they can actually see them. </s></p></div1><div1 type="section"><head rend="bold">Progress to Date</head><p n="p10.39"><s n="s1.1;p10.39">This is a report of my progress, 6 months after writing the preliminary report. </s></p><div2><head rend="bold">Analysis and Design</head><p n="p11.39"><s n="s1.1;p11.39">The set of requirements have changed significantly since the preliminary report as the focus has moved from a fully-featured PDA application with a small supporting PC application to two well-featured applications - one for PC and one for the PDA. </s></p><p n="p12.39"><s n="s1.3;p12.39">Some restraints have been added after making a prototype, which highlighted unforeseen problems. </s><s n="s2.3;p12.39">An example is the new requirement that height data featuring on the horizon has to be at least 1.5 km from the observer. </s><s n="s3.3;p12.39">This is because it was only when the prototype had been made that I realised that close data is too sparse relative to distant data to be meaningful. </s></p><p n="p13.39"><s n="s1.1;p13.39">The current set of requirements is as follows: </s></p><list type="bulleted"><head>For the PC Application:</head><item>For the user to be able to select the area of the country in which they are going to walk, either from raster Ordinance Survey maps, or from graphical height maps.</item><item>To convert the relevant height data into a format easily read by the PDA.</item><item>To create a data file containing all of the hills that fall within the range specified by the height data above.</item><item>To allow the user to see the horizon of a point within their walk from this data</item><item>To show the user what areas of the map the horizon represents</item><item>To give the user the ability to add 'markers', for example the start and end points of the route. These will be displayed on the PDA whether or not the land upon which they are found is physically visible to the user.</item></list><list type="bulleted"><head>For the PDA Application:</head><item>For the user to be able to enter their current grid-reference</item><item>To tell the user their height</item><item>To draw a horizon:</item><item>Representing a scrollable 360 degree panorama</item><item>Containing only data at least 1.5km from the observer</item><item>Naming all identifiable hills</item><item>Being able to show how far a hill is away, and its height</item><item>For markers to be labelled, whether or not they are visible, along with how far they are away.</item><item>For the horizon to be drawn in a reasonable amount of time (i.e. within 20 seconds)</item><item>For the horizon to be easily navigable, so that the user knows the direction in which the current portion of the scrolling horizon is facing.</item><item>There shall be a representation of the horizon that fits into one screen-width, which can be used to show where the current window is on the horizon, and allow the user to click to jump to another part of the horizon.</item><item>There shall be a compass pointing in the direction (relative to the orientation of the PDA) that the horizon is currently looking.</item><item>To give the user the ability to add markers.</item></list><p n="p14.39"><s n="s1.1;p14.39">The prototype has been invaluable in deciding what is feasible and in creating new ideas, and it has also meant that I was able to start the actual implementation with the designs of the algorithms and data structures fairly fixed. </s></p></div2><div2><head rend="bold">Development and Implementation</head><p n="p15.39"><s n="s1.2;p15.39">The first stage of the development was to make a prototype in Microsoft Visual Basic. </s><s n="s2.2;p15.39">I chose this language as it is very fast to program, and the fact that the efficiency of the prototype wasn't an issue. </s></p><p n="p16.39"><s n="s1.2;p16.39">The prototype is a PC application that allows the user to click on a graphical representation of the height data of the current map, and set an observer to this point. </s><s n="s2.2;p16.39">The program will then draw the 360 horizon and label all the hills. </s></p><figure id="BAWE_6101j-fig.001"><head>Screen shot of prototype running, taken 15 <hi rend="sup">th</hi> November 2005.</head></figure><p n="p17.39"><s n="s1.2;p17.39">One of the most important things I decided while making the prototype was the way in which the algorithm would work. </s><s n="s2.2;p17.39">The first thing I tried was to use a sector: </s></p><figure id="BAWE_6101j-fig.002"/><p n="p18.39"><s n="s1.4;p18.39">In the diagram above, a sector of angle A is swept around the observer. </s><s n="s2.4;p18.39">For every position of the sector, the elevations for every item of height data are looked at and the maximum is taken as the height of the horizon for that sector. </s><s n="s3.4;p18.39">Note that angle A is much larger in the diagram than in the program. </s><s n="s4.4;p18.39">Angle A is typically about 0.25. </s></p><p n="p19.39"><s n="s1.2;p19.39">This method is quite slow, however, because every time angle A is moved, each height reading in the quadrant needs to be checked to see whether it falls within the sector. </s><s n="s2.2;p19.39">A better solution is the following idea: </s></p><figure id="BAWE_6101j-fig.003"/><p n="p20.39"><s n="s1.3;p20.39">The line sweeps around the observer, and at each point the program interpolates along the line at a given interval. </s><s n="s2.3;p20.39">This means that it can find the map data item directly for each reading, and then take a maximum at the end. </s><s n="s3.3;p20.39">This method is about 20 times faster than the previous method in a 20km square map, so as efficiency is such an issue with a PDA, this was perhaps the most important finding of the prototype. </s></p><p n="p21.39"><s n="s1.1;p21.39">Another very important thing that the prototype made me realise was the significance of close data. </s></p><figure id="BAWE_6101j-fig.004"/><p n="p22.39"><s n="s1.1;p22.39">If the observer is standing on a steep slope, then it is very reasonable for an adjacent height in the map data to be significantly higher than the observer is, given that the adjacent square is actually 50m away on the ground. </s></p><p n="p23.39"><s n="s1.4;p23.39">Suppose, for example, that the shaded square was a lot higher than the observer (marked with a black circle). </s><s n="s2.4;p23.39">In this case, the elevation of this reading will probably be the maximum of any line that interpolates through. </s><s n="s3.4;p23.39">This will mean that 90 degrees of the horizon (from North-West to North-East) will be all based on one reading. </s><s n="s4.4;p23.39">This will give a misleadingly flat line through a quarter of the horizon as so much of what the observer can see is assumed to be the same as one single height reading. </s></p><p n="p24.39"><s n="s1.2;p24.39">There seems to be only two ways of fixing this. </s><s n="s2.2;p24.39">That is either to have more data (a reading every 10m for example), or to ignore all the readings within a radius of the observer. </s></p><p n="p25.39"><s n="s1.4;p25.39">If we supplied the PDA with data at 10m intervals (the next scale that DigiMap produces) rather than 50, we will be giving in effect 25 times more data. </s><s n="s2.4;p25.39">This is far more than can be expected to be processed in a reasonable time, so is unrealistic. </s><s n="s3.4;p25.39">I decided to give the application a radius of 1.5km within which all data is ignored. </s><s n="s4.4;p25.39">I chose this figure because a single item of data 1.5km away takes up a modest amount of horizon, and so looks natural. </s></p><p n="p26.39"><s n="s1.2;p26.39">A map can be selected for the prototype graphically using a second program (shown below). </s><s n="s2.2;p26.39">The main reason I implemented this was so that I knew how the maps fitted together and understood where a single map was in relation to the country. </s></p><figure id="BAWE_6101j-pic.005"><head rend="italic">A screenshot of the program I used to select a map. Each square of the grid represents a 20km square map, which can be loaded into the prototype. </head></figure><p n="p27.39"><s n="s1.3;p27.39">The third program I made used a hill-climbing algorithm to refine the grid-references of the hill summits to the local highpoints. </s><s n="s2.3;p27.39">The following capture shows it in operation. </s><s n="s3.3;p27.39">For each hill, the first entry in the list is the original set of co-ordinates stored for its summit, and this is refined over each iteration till the final entry for that mountain in the list is the new summit at the local highpoint. </s></p><figure id="BAWE_6101j-pic.006"><head rend="italic"> The hill-climbing algorithm in operation. </head></figure><p n="p28.39"><s n="s1.1;p28.39">I then used the experience and knowledge gleamed from the prototype to make an application for the PDA. I am currently at the stage where a horizon is drawn to the PDA, and am finalising the code for the hills to be labelled. </s></p><figure id="BAWE_6101j-pic.007"><head rend="italic">Screen shots of the PDA application so far. The horizon of the screenshot on the right has been scrolled clockwise. The top line, the screen-width summary of the horizon, has been stretched vertically to pronounce hills. </head></figure><p n="p29.39"><s n="s1.1;p29.39">For a full description of the development and implementation process, please refer to the project log. </s></p></div2><div2><head rend="bold">Testing, Quality and Correctness Analysis</head><p n="p30.39"><s n="s1.3;p30.39">The main problem I have been having through this project is determining whether a horizon is accurate. </s><s n="s2.3;p30.39">It is very difficult to look at a line on a screen and decide whether it looks like a Welsh mountain. </s><s n="s3.3;p30.39">For this reason, I installed ArcGIS, which allowed me to drape a raster Ordinance Survey map over a range of height data, and then observe a hill from a particular spot. </s></p><p n="p31.39"><s n="s1.4;p31.39">I have proved the horizon to be accurate in this way by creating two views of Snowdon from Yr Aran. </s><s n="s2.4;p31.39">ArcGIS rendered one, and my program the other. </s><s n="s3.4;p31.39">In the following image, for example, the top line is the output from the program, and the coloured mountains are the output from ArcGIS. When superimposed, one fits exactly on the other, and this seems to be the case wherever you set the observer, and whichever direction you look. </s><s n="s4.4;p31.39">I concluded, therefore, that the horizon algorithms are accurate. </s></p><figure id="BAWE_6101j-fig.005"/><p n="p32.39"><s n="s1.3;p32.39">This term I plan to test the project further by taking it to Snowdonia and testing it in the field. </s><s n="s2.3;p32.39">This will be a very good indication of how accurately the horizon resembles what the observer can actually see. </s><s n="s3.3;p32.39">I will take photographs to highlight any discrepancies. </s></p></div2></div1><div1 type="section"><head rend="bold">Plan for the Remainder of the Project Period</head><table id="BAWE_6101j-tab.001"><row><cell/></row></table><table id="BAWE_6101j-tab.002"><row><cell/></row></table><p n="p33.39"><s n="s1.3;p33.39">As the Gantt chart above indicates, my plan is to first finish the PDA application. </s><s n="s2.3;p33.39">This should be done in about a week, and at this point I will write the PC application and take the PDA application to Snowdonia to test it in the field. </s><s n="s3.3;p33.39">The PC application should take between 3 and 4 weeks. </s></p><p n="p34.39"><s n="s1.2;p34.39">Towards the end of the implementation period for the PC application I will demonstrate both applications, then I will perform full testing and add any other features that seem necessary. </s><s n="s2.2;p34.39">I will then start work on the final report. </s></p></div1><div1 type="section"><head rend="bold">Summary and Critique</head><p n="p35.39"><s n="s1.2;p35.39">The requirements for the project have changed substantially since the preliminary report due to what has been learned from the prototype. </s><s n="s2.2;p35.39">For this reason, it is very difficult to compare the Gantt chart in the preliminary report with that of this report and decide whether or not I am on schedule. </s></p><p n="p36.39"><s n="s1.3;p36.39">I believe, however, that I am on schedule as I have completed all the algorithms and the entire system has been designed. </s><s n="s2.3;p36.39">The implementation of the PDA application has been far faster than I was expecting because I am so familiar with the workings of the algorithms. </s><s n="s3.3;p36.39">I am hoping that the PC application will be just as swift to implement, in which case I will be ahead of schedule. </s></p><p n="p37.39"><s n="s1.1;p37.39">I think if I continue at my current rate, I should finish well in time for the deadlines. </s></p><p n="p38.39"><s n="s1.6;p38.39">The PDA application is running slower than I was expecting, however, but this is due to the speed of the PDA rather than the algorithms. </s><s n="s2.6;p38.39">I will make the code as efficient as possible to increase the speed. </s><s n="s3.6;p38.39">I have realised that memory space is less of an issue on a PDA than processor speed, as usually only one program is running at once. </s><s n="s4.6;p38.39">Therefore it is generally better to perform one calculation and store the result to use again than to repeat a calculation. </s><s n="s5.6;p38.39">I have made the program, therefore, calculate the distance from the observer to everywhere on the map before the horizon algorithm runs. </s><s n="s6.6;p38.39">This means that these will not need to be recalculated. </s></p><p n="p39.39"><s n="s1.1;p39.39">I am extremely pleased with the accuracy of the horizon, as supported by the tests I made with ArcGIS. </s></p></div1></body><back><div1 type="bibliography"><head rend="bold">References and Acknowledgements</head><div2 type="bibliography"><head rend="bold">References</head><p>[1] Google Maps, <seg type="URL" n="http://earth.google.com/earth.html"/></p><p>[2] ESRI ArcGIS, <seg type="URL" n="http://www.esri.com/software/ArcGIS/"/></p><p>[3] Memory Map, <seg type="URL" n="http://www.memory-map.co.uk/software.htm"/></p><p>[4] ESRI ArcPad, <seg type="URL" n="http://www.esri.com/software/ArcGIS/arcpad/index.html"/></p></div2><div2 type="bibliography"><head rend="bold">Acknowledgements</head><p>Edina Digimap and Ordnance Survey for all height data and maps. These are protected under Crown Copyright 2006, but are made available for educational use. For more information, visit <seg type="URL" n="http://edina.ac.uk/digimap/"/>.</p></div2></div1></back></text></TEI.2>
