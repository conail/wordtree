<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_6160b" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>Pseudocode Coursework 1</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">Page header contains: date; student name; student number. 
Page footer contains: page number. 
</note></notesStmt><sourceDesc><p n="level">1</p><p n="date">2006-10</p><p n="module title">Computer Science Roadmap</p><p n="module code">SE1SC5</p><p n="genre family">Design specification</p><p n="discipline">Computer Science</p><p n="disciplinary group">PS</p><p n="grade">D</p><p n="number of authors">1</p><p n="number of words">957</p><p n="number of s-units">45</p><p n="number of p">20</p><p n="number of tables">0</p><p n="number of figures">0</p><p n="number of block quotes">0</p><p n="number of formulae">4</p><p n="number of lists">1</p><p n="number of paragraphs formatted like lists">4</p><p n="abstract present">no abstract</p><p n="average words per s-unit">21.3</p><p n="average s-units per p">2.3</p><p n="macrotype of assignment">simple assignment</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">m</p><p n="year of birth">1987</p><p n="first language">English</p><p n="education">UKa</p><p n="course">BSc Computer Science</p><p n="student ID">6160</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><docTitle><titlePart rend="underlined bold">Pseudocode Coursework 1</titlePart></docTitle></titlePage></front><body><div1 type="section"><head rend="underlined"><hi rend="bold">1. Introduction</hi><hi rend="italic">and informal statement of requirements</hi></head><p n="p1.20"><s n="s1.2;p1.20">In the course of playing the video game <hi rend="italic">Ratchet and Clank</hi>, the player will encounter various (often useful) objects. </s><s n="s2.2;p1.20">Thus, one of the objectives of the game is to collect as many of these objects as possible. </s></p><p n="p2.20"><s n="s1.2;p2.20">For any given objective (or <hi rend="italic">problem</hi>) for which there exists a computable solution, there may be one or more possible solutions which will produce the desired result. </s><s n="s2.2;p2.20">This coursework aims to develop one such solution- i.e. to attempt to discover the best way to collect as many objects as possible. </s></p><div2><head rend="underlined">Assumptions</head><p n="p3.20"><s n="s1.2;p3.20">For any model, assumptions about the operating environment must be made. </s><s n="s2.2;p3.20">I assume the following: </s></p><p n="p4.20"><s n="s1.5;p4.20">In the game, there exist infinite instances of <hi rend="bold italic">each</hi> of the types of objects (e.g. in a crate containing <hi rend="italic">only</hi> apples and pears, there are infinite apples and infinite pears). </s><s n="s2.5;p4.20">This allows that at least one of each object can be collected. </s><s n="s3.5;p4.20">Also, this assumption is made because the exact numbers are unknown. </s><s n="s4.5;p4.20">Objects will be encountered randomly- i.e. randomly distributed within the universal set. </s><s n="s5.5;p4.20">Finally, it is assumed that as listed on the exercise sheet, there are 11 distinct objects. </s></p></div2><div2><head><hi rend="underlined">Requirements</hi> :</head><p n="p5.20"><s n="s1.2;p5.20">The algorithm must produce a set containing a single instance of each object, with no duplicates. </s><s n="s2.2;p5.20">When the set contains one of each type of object, the set is complete and the algorithm will terminate. </s></p></div2></div1><div1 type="section"><head rend="underlined bold">2. The Algorithm</head><div2><head rend="underlined">Initial conditions:</head><p rend="bulleted" n="p6.20"><s n="s1.1;p6.20">The universal set <hi rend="bold">U</hi> contains infinite instances of all the objects. </s></p><p rend="bulleted" n="p7.20"><s n="s1.1;p7.20">The set <hi rend="bold">C</hi> which will hold the collected objects is initially empty. </s></p><p rend="bulleted" n="p8.20"><s n="s1.2;p8.20">The constant <hi rend="bold italic">d</hi> is defined as the number of distinct elements in set <hi rend="bold">U</hi>, i.e. the number of <hi rend="italic">different</hi> objects. </s><s n="s2.2;p8.20">For this example, <hi rend="bold italic">d</hi> is assumed to be 11. </s></p><p rend="bulleted" n="p9.20"><s n="s1.2;p9.20">The variable <hi rend="bold italic">s</hi> is defined as the number of elements in <hi rend="bold">C</hi>. </s><s n="s2.2;p9.20">It is initially equal to zero. </s></p></div2><div2><head rend="underlined">2a. Expressed informally as a sequence of steps</head><p n="p10.20"><s n="s1.1;p10.20"><formula notation="" id="BAWE_6160b-form.001"/> </s></p></div2><div2><head rend="underlined">2b. Expressed as Pseudocode</head><p n="p11.20"><s rend="italic" n="s1.3;p11.20">In this section I make comments in italics. </s><s n="s2.3;p11.20"><hi rend="italic">Arrays are defined using the zero-based convention, thus the first element of array</hi> U <hi rend="italic"> is</hi> U[0]. </s><s n="s3.3;p11.20">NULL <hi rend="italic"> will be used to signify an empty element- when an object is picked up, it is no longer a part of the universal set and the position it was in is now empty.</hi> </s></p><p n="p12.20"><s n="s1.1;p12.20"><formula notation="" id="BAWE_6160b-form.002"/> </s></p><p n="p13.20"><s rend="italic" n="s1.2;p13.20">Next I define the subroutine for the PickUp operation, first the object is "picked up" and added to the collection then the cardinality of C is checked (the number of distinct elements). </s><s rend="italic" n="s2.2;p13.20">If newly added object already exists then s+1 will be greater than cardinality of C or else if new object is unique, s+1 = |C|: </s></p><p n="p14.20"><s n="s1.1;p14.20"><formula notation="" id="BAWE_6160b-form.003"/> </s></p><p n="p15.20"><s rend="italic" n="s1.4;p15.20">I define the subroutine for the Drop operation. </s><s rend="italic" n="s2.4;p15.20">The element of the array is set to NULL to represent that object being removed from collection. </s><s n="s3.4;p15.20"><hi rend="italic">The removed object</hi> U[i]<hi rend="italic"> is a duplicate instance of an already existing object in the set C. This is verified by finding the set complement between the set X and C. X</hi> <hi rend="italic">contains a single element: the single removed object.</hi> </s><s rend="italic" n="s4.4;p15.20">If the removed object exists in both X and C then the set complement is an empty set : </s></p><p n="p16.20"><s n="s1.1;p16.20"><formula notation="" id="BAWE_6160b-form.004"/> </s></p></div2></div1><div1 type="section"><head rend="underlined bold">3. Algorithm Properties:</head><list type="ordered"><item><hi rend="underlined">Input:</hi> The Universal set <hi rend="bold">U</hi> containing at least one of each type of object, the number of distinct objects (represented by the constant <hi rend="bold">d</hi>).</item><item><hi rend="underlined">Output:</hi> The set of collected objects, C. </item><item><hi rend="underlined">Definiteness:</hi> The main function Play uses a <hi rend="italic">while</hi> loop to go through the set U and uses the PickUp subroutine to collect objects and Drop to discard duplicates. </item><item><hi rend="underlined">Finiteness:</hi> When s = d, the set C is complete and contains one of each type of object- at this point the program terminates.</item><item><hi rend="underlined">Effectiveness:</hi> Each step of the algorithm is either a comparison or an assignment operation so will take a finite amount of time.</item><item><hi rend="underlined">Corrrectness:</hi> Yes, algorithm results in a set containing all distinct elements. Tested using d=2 with U containing 5 elements.</item></list><p n="p17.20"/></div1><div1 type="section"><head rend="underlined bold">4. Algorithm Efficiency:</head><p n="p18.20"><s n="s1.5;p18.20">The program is controlled by a while loop so the time need to execute the algorithm is ultimately dependent on the nature of the universal set <hi rend="bold">U</hi> as this governs the time taken for the <hi rend="bold italic">while</hi> loop (controlling the program) to complete. </s><s n="s2.5;p18.20">A greater number of distinct elements in <hi rend="bold">U</hi> results in a longer execution time. </s><s n="s3.5;p18.20">The actual execution time is affected by the distribution of the elements within <hi rend="bold">U.</hi> </s><s n="s4.5;p18.20">For example, when attempting to obtain a set containing the elements {3,1, 4, 2}, the algorithm would achieve this faster from a set such as {<hi rend="bold">2,3,4,1</hi>,4,3,1,2,1,4} rather than (<hi rend="bold">2</hi>,2,2,2,2,2,2,<hi rend="bold">3,1,4</hi>}. </s><s n="s5.5;p18.20">On the basis of the model used in developing this algorithm, the execution time would vary due across runs due to the random distribution of the elements contained within the set <hi rend="bold">U</hi> (see <hi rend="italic">Assumptions</hi>). </s></p><p n="p19.20"><s n="s1.4;p19.20">If the number of distinct objects is given by the constant <hi rend="bold">d</hi>, the ideal <hi rend="bold">U</hi> set would be one where there is no repetition within the first <hi rend="bold">d</hi> elements. </s><s n="s2.4;p19.20">Whatever comes after is irrelevant. </s><s n="s3.4;p19.20">Using the exercise example of <hi rend="bold">d=11</hi>, taking into account 11 runs of the <hi rend="italic">While</hi> loop, I estimate that at least 78 (11 x 7 steps per completed <hi rend="italic">While +</hi> 1 last check of <hi rend="italic">While</hi> condition to terminate) steps are required to obtain a set of 11 distinct objects. </s><s n="s4.4;p19.20">This assumes that calling a subroutine is only counted once, as a single step, ignoring their internal steps. </s></p></div1><div1 type="section"><head rend="underlined bold">5. Application of Sets:</head><p n="p20.20"><s n="s1.4;p20.20">A common application of sets could be in programs that generate random sets of numbers for lottery tickets, bingo, etc. </s><s n="s2.4;p20.20">So for example, with the National Lottery, there may be set <hi rend="bold">U = {1,2,3,4...</hi> </s><s rend="bold" n="s3.4;p20.20">48,49}. </s><s n="s4.4;p20.20">The program must then generate subsets which contain 6 elements with no repetitions within the sets. </s></p></div1></body><back/></text></TEI.2>
