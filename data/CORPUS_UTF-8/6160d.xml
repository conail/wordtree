<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_6160d" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>Pseudocode Coursework 3 - Tree data model</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">Page header contains: date; student name; student number. 
Page footer contains: page number. 
</note></notesStmt><sourceDesc><p n="level">1</p><p n="date">2006-11</p><p n="module title">Computer Science Roadmap</p><p n="module code">SE1SC5</p><p n="genre family">Design specification</p><p n="discipline">Computer Science</p><p n="disciplinary group">PS</p><p n="grade">D</p><p n="number of authors">1</p><p n="number of words">903</p><p n="number of s-units">44</p><p n="number of p">29</p><p n="number of tables">1</p><p n="number of figures">2</p><p n="number of block quotes">0</p><p n="number of formulae">2</p><p n="number of lists">4</p><p n="number of paragraphs formatted like lists">6</p><p n="abstract present">no abstract</p><p n="average words per s-unit">20.5</p><p n="average s-units per p">1.5</p><p n="macrotype of assignment">simple assignment</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">m</p><p n="year of birth">1987</p><p n="first language">English</p><p n="education">UKa</p><p n="course">BSc Computer Science</p><p n="student ID">6160</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><docTitle><titlePart rend="underlined bold">Pseudocode Coursework 3 - Tree data model</titlePart></docTitle></titlePage></front><body><div1 type="section"><head rend="underlined bold">1. Introduction</head><p n="p1.29"><s n="s1.2;p1.29">The tree data model is used in computer science for things like file systems and search algorithms. </s><s n="s2.2;p1.29">Trees are also used in modelling chemical structures and biological systems. </s></p><p n="p2.29"><s n="s1.2;p2.29">This coursework will investigate tree models as applied to binary search and also look at the procedure for inserting data into such a tree. </s><s n="s2.2;p2.29">This coursework will result in a better understanding of how to model a problem based on the tree model. </s></p><p n="p3.29"><s n="s1.2;p3.29">The <hi rend="italic">degree</hi> of the tree that will be used is the maximum number of child nodes that any particular node can have. </s><s n="s2.2;p3.29">In this case, where a binary tree will be used, the degree is 2. </s></p><p n="p4.29"><s n="s1.2;p4.29">An algorithm is to be devised to <hi rend="italic">insert</hi> data into a binary tree and thus construct trees for the data. </s><s n="s2.2;p4.29">The following datasets will be involved: </s></p><list type="bulleted"><item>List of all SSE degree courses </item><item>A subset of counties in England.</item></list><div2><head rend="underlined">Informal statement of requirements</head><p n="p5.29"><s n="s1.2;p5.29">The insertion algorithm should result in a tree containing all elements of the dataset in ascending alphanumeric order (i.e. </s><s n="s2.2;p5.29">A to Z, 0 to 9). </s></p><p n="p6.29"><s n="s1.1;p6.29">The tree will consist of nodes such that every node other that the root node will have one parent node and either: </s></p><list type="bulleted"><item>Zero child nodes</item><item>One Left child node</item><item>One Right child node</item><item>Both a Left and a Right child node.</item></list><p n="p7.29"><s n="s1.2;p7.29">There should be no repetition- i.e. all nodes in the tree must have unique values. </s><s n="s2.2;p7.29">Therefore the algorithm must check if adding the current item duplicates an existing item and discard if this is the case. </s></p><p n="p8.29"><s n="s1.1;p8.29">The value of all nodes in the left sub-trees must be less than the value of the node it descends from. </s></p><p n="p9.29"><s n="s1.1;p9.29">The value of all nodes in the right sub-trees must be greater than the value of the node it descends from. </s></p></div2></div1><div1 type="section"><head rend="underlined bold">2. The Algorithm</head><div2><head rend="underlined">As an Informal Series of Steps</head><p n="p10.29"><s n="s1.1;p10.29">If a non-existing node is referenced, its value is automatically <hi rend="bold">NULL</hi>. </s></p><p n="p11.29"><s n="s1.1;p11.29">The algorithm will start building tree from the root node. </s></p><p n="p12.29"><s n="s1.1;p12.29"><formula notation="" id="BAWE_6160d-form.001"/> </s></p></div2><div2><head rend="underlined">As Pseudocode</head><p n="p13.29"><s n="s1.1;p13.29">The Pseudocode will be designed with the following assumptions: </s></p><p rend="bulleted" n="p14.29"><s n="s1.2;p14.29">The data set <hi rend="bold">D</hi> that the algorithm will operate on is a finite set with <hi rend="bold">N</hi> elements and <hi rend="bold">D</hi>[x] refers to element x of the dataset. </s><s n="s2.2;p14.29">It will be modelled as a single-dimension array. </s></p><p rend="bulleted" n="p15.29"><s n="s1.1;p15.29"><hi rend="bold">R</hi> and <hi rend="bold">C</hi> are nodes. </s></p><p rend="bulleted" n="p16.29"><s n="s1.3;p16.29">Nodes may possibly have child <hi rend="bold">C</hi> nodes. </s><s n="s2.3;p16.29">There may be 0, 1 or 2 C nodes. </s><s n="s3.3;p16.29">A parent node may have either one child of either type <hi rend="bold">left[R]</hi> or <hi rend="bold">right[R]</hi> or have both child nodes. </s></p><p rend="bulleted" n="p17.29"><s n="s1.2;p17.29">The type of the node will be determined by whether the value of <hi rend="bold">C</hi> is less than or greater than the value of <hi rend="bold">R.</hi> </s><s n="s2.2;p17.29">If less, it is a left child (<hi rend="bold">left[R]</hi>) else it is a (<hi rend="bold">right[R]</hi>). </s></p><p rend="bulleted" n="p18.29"><s n="s1.1;p18.29">Empty or non-existent nodes return the value <hi rend="bold">NULL</hi> when referenced </s></p><p rend="bulleted" n="p19.29"><s n="s1.1;p19.29">The data will be stored into the tree <hi rend="bold">T.</hi> </s></p><figure id="BAWE_6160d-fig.001"/><p n="p20.29"><s n="s1.1;p20.29">The Pseudocode for this algorithm is as follows. </s></p><p n="p21.29"><s n="s1.1;p21.29"><formula notation="" id="BAWE_6160d-form.002"/> </s></p></div2><div2><head rend="underlined">Testing</head><p n="p22.29"><s n="s1.1;p22.29">The two sample datasets that the algorithm is to run on are: </s></p><list type="bulleted"><item>List of all SSE degree courses </item><item>A subset of counties in England.</item></list><p n="p23.29"><s n="s1.1;p23.29">Here the algorithm will be used for each in turn. </s></p><div3><head rend="underlined">List of all SSE degree courses </head><p n="p24.29"><s n="s1.3;p24.29">This is a list of SSE degree courses (copied directly from the various SSE pages, for CS, Cyb, EE, IT). </s><s n="s2.3;p24.29">For the ease of display of the tree, the algorithm shall run on the UCAS codes of the degree programmes. </s><s n="s3.3;p24.29">The convention for sorting used is numbers before letters, i.e. : 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ </s></p><table id="BAWE_6160d-tab.001"><row><cell/></row></table><p n="p25.29"><s n="s1.3;p25.29">The resulting tree is shown on the next page. </s><s n="s2.3;p25.29">It is an unbalanced tree because the root used would not be the middle item if the elements were ordered alphabetically. </s><s n="s3.3;p25.29">In an alphabetical list, the root would be located near the end of the list, this is why the tree left-heavy. </s></p><figure id="BAWE_6160d-fig.002"><head rend="bold">Binary Search Tree of SSE Degrees</head></figure></div3><div3><head rend="underlined">Subset of Counties in England</head><p n="p26.29"><s n="s1.2;p26.29">The following shows the <hi rend="underlined">worst possible use</hi> of a binary tree. </s><s n="s2.2;p26.29">As the dataset is already in alphabetical order, the resulting tree is nothing more than a list and offers no additional advantages compared to a normal list. </s></p></div3></div2><div2><head rend="underlined">Steps to Insert an Item</head><p n="p27.29"><s n="s1.2;p27.29">For the first tree (SSE degrees), the longest path from root to leaf is 11 elements including the root. </s><s n="s2.2;p27.29">Therefore for that tree, up to 11 iterations of the algorithm loop would be required to insert a new item. </s></p><p n="p28.29"><s n="s1.1;p28.29">The inefficiency of the second tree (subset of English counties) is demonstrated by the fact that despite being built from a smaller dataset (18 counties versus 24 SSE degrees), it would take up to 18 iterations to insert a new item. </s></p></div2></div1><div1 type="section"><head rend="underlined bold">3. Algorithm Properties:</head><list type="ordered"><item><hi rend="underlined">Input:</hi> The dataset containing the data that is to be inserted into a binary tree.</item><item><hi rend="underlined">Output:</hi> The binary search tree T. </item><item><hi rend="underlined">Definiteness:</hi> The algorithm exhibits definiteness in that all data that will be inserted into the tree will one and only one of the following: be equal to the top node, greater than the top node or less than the top node. Comparison statements identify which of these is the case for each data item to be inserted so that it can be insert to the correct location by an assignment statement. A loop ensures that every data item is dealt with. </item><item><hi rend="underlined">Finiteness:</hi> The algorithm terminates when all data has been inserted.</item><item><hi rend="underlined">Effectiveness:</hi> Each step of the algorithm is either a comparison or an assignment operation so will take a finite amount of time.</item><item><hi rend="underlined">Corrrectness:</hi> Yes, algorithm results in a binary search tree of the data.</item></list><p n="p29.29"/></div1></body><back/></text></TEI.2>
