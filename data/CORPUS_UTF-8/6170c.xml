<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd"><TEI.2 id="_6170c" n="version 1.0"><teiHeader><fileDesc><titleStmt><title>Coursework</title></titleStmt><extent/><publicationStmt><distributor>British Academic Written English (BAWE) corpus</distributor><availability><p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p><p>1. The corpus files are not distributed in either their original form or in modified form.</p><p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p><p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p><p>4. The BAWE corpus developers (contact: Hilary Nesi) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p><p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p></availability></publicationStmt><notesStmt><note resp="British Academic Written English (BAWE) corpus project">The document has a title page which contains:
document title
title part</note></notesStmt><sourceDesc><p n="level">4</p><p n="date">2007-01</p><p n="module title">Real-time and Embedded Systems</p><p n="module code">M64CS</p><p n="genre family">Explanation + Design specification</p><p n="discipline">Computer Science</p><p n="disciplinary group">PS</p><p n="grade">M</p><p n="number of authors">1</p><p n="number of words">3339</p><p n="number of s-units">137</p><p n="number of p">74</p><p n="number of tables">1</p><p n="number of figures">4</p><p n="number of block quotes">0</p><p n="number of formulae">6</p><p n="number of lists">20</p><p n="number of paragraphs formatted like lists">5</p><p n="abstract present">no abstract</p><p n="average words per s-unit">24.4</p><p n="average s-units per p">1.9</p><p n="macrotype of assignment">simple assignment</p></sourceDesc></fileDesc><encodingDesc><p>TEI P4 (documented in: BAWE.documentation.pdf)</p></encodingDesc><profileDesc><particDesc><person><p n="gender">f</p><p n="year of birth">1983</p><p n="first language">Polish</p><p n="education">OSa</p><p n="course">MSc Computing</p><p n="student ID">6170</p></person></particDesc></profileDesc></teiHeader><text><front><titlePage><titlePart><hi rend="bold"><name type="university"/></hi> School of Mathematical and Information Sciences</titlePart><docTitle><titlePart rend="bold">M64CS - Real-time and Embedded Systems</titlePart></docTitle><titlePart>Author <hi rend="bold"><name type="student name"/></hi> Student ID <name type="student ID"/> Course Title MSc Computing Module M64CS - Real-time and Embedded Systems Date 22/01/2007</titlePart></titlePage><div1 type="toc" n="3"><head rend="bold">Table of Content</head><p/></div1></front><body><div1 type="section"><head rend="bold">Part 1: Communication and synchronisation mechanisms and formal method definition</head><div2><head rend="bold italic">Semaphores, monitors and message passing</head><div3><head rend="bold">Semaphores</head><p n="p1.74"><s n="s1.2;p1.74">Semaphore is an abstract data type invented by a Dutch computer scientist E.W. Dijkstra in middle 1960's. </s><s n="s2.2;p1.74">It was first introduced and successfully implemented to protect critical sections. </s></p><p n="p2.74"><s n="s1.1;p2.74">Semaphore is a shared, nonnegative integer variable which can be manipulated exclusively by only two operations: </s></p><list type="bulleted"><item>P(s) for wait (Dutch word <hi rend="italic">Passeren</hi>)</item><item>V(s) for signal (Dutch word <hi rend="italic">Vrygeven</hi>)</item></list><p n="p3.74"><s n="s1.2;p3.74">Both operations are indivisible - it means they are executed as atomic actions. </s><s n="s2.2;p3.74">The third operation on semaphore is its initialisation "init". </s></p><p n="p4.74"><s n="s1.1;p4.74">There are two approaches in using the semaphores for synchronisation: </s></p><list type="bulleted"><item>Binary semaphores - can have only two values: 0 and 1</item><item>Counting semaphores - can have any nonnegative values.</item></list><div4><head rend="underlined">How the semaphore works</head><p n="p5.74"><s n="s1.3;p5.74">The current value of the semaphore represents the number of free resource units that can be used at this time. </s><s n="s2.3;p5.74">The binary semaphores are used in cases, where there is only one unit which can be either available or not available. </s><s n="s3.3;p5.74">For plural number of units the counting semaphores are implemented. </s></p><p n="p6.74"><s n="s1.3;p6.74">If the semaphore value is positive it means that there are available resources and that they can be used. </s><s n="s2.3;p6.74">Each resource unit occupation results in decrementing the semaphore value. </s><s n="s3.3;p6.74">If the semaphore value is 0 it means that all resources are currently being used and the process must wait until the resources are available again. </s></p></div4><div4><head rend="underlined">Operations on semaphores</head><p n="p7.74"><s n="s1.2;p7.74">In order to decrease the value of the semaphore we use P(s) operation. </s><s n="s2.2;p7.74">This operation decrements the value of s as long as s>0: </s></p><p n="p8.74"><s n="s1.1;p8.74"><formula notation="" id="BAWE_6170c-form.001"/> </s></p><p n="p9.74"><s n="s1.1;p9.74"><formula notation="" id="BAWE_6170c-form.002"/> the process is put to wait until <hi rend="italic">s</hi> is positive so that the process may proceed again </s></p><p n="p10.74"><s n="s1.3;p10.74">In order to increase the value of the semaphore we use V(s) operation. </s><s n="s2.3;p10.74">If <hi rend="italic">s</hi> was equal to 0 and there are any processes waiting, one process will be then awaken and able to proceed. </s><s n="s3.3;p10.74">In other case <hi rend="italic">s</hi> is atomically increased by one. </s></p><p n="p11.74"><s n="s1.1;p11.74">The "init" operation is performed only once for a single semaphore before any semaphore requests are made e.g. </s></p><p n="p12.74"><s n="s1.1;p12.74"><formula notation="" id="BAWE_6170c-form.003"/> </s></p></div4><div4><head rend="underlined">Examples of usage</head><p n="p13.74"><s n="s1.5;p13.74">The most common semaphore is a binary semaphore used for Mutual Exclusion. </s><s n="s2.5;p13.74">It controls the access to a single resource used by two or more different processes. </s><s n="s3.5;p13.74">Its aim is to assure that only one process at a time can access the resource. </s><s n="s4.5;p13.74">This kind of semaphore is typically initialized with value 1. </s><s n="s5.5;p13.74">It is decreased to 0 each time a process accesses the resource and then increased to one each time the resource is freed. </s></p><p n="p14.74"><s n="s1.1;p14.74">We can also use semaphores when we want to make sure that one section of the code is run before another section executed by completely different process. </s></p></div4><div4><head rend="underlined">Disadvantages</head><p n="p15.74"><s n="s1.2;p15.74">Semaphores are relatively difficult in implementation. </s><s n="s2.2;p15.74">It is very easy to make mistakes such as forgetting the signal operation V(s), especially when several semaphores are used. </s></p><p n="p16.74"><s n="s1.1;p16.74">Due to lack of relationship between the operation name and mnemonic used for its description it is also very easy to mix up wait(s) - P(s) and signal(s) - V(s). </s></p></div4></div3><div3><head rend="bold">Monitors</head><p n="p17.74"><s n="s1.5;p17.74">Monitor is a structure invented by a Danish computer scientist Per Brinch Hansen in 1972. </s><s n="s2.5;p17.74">Monitors are implemented to assure synchronization of different processes that use some shared resource. </s><s n="s3.5;p17.74">They were introduced as a more structured approach than semaphores. </s><s n="s4.5;p17.74">They can be found in many concurrent languages e.g. </s><s n="s5.5;p17.74">Java. </s></p><p n="p18.74"><s n="s1.1;p18.74">The monitors became very popular as they provide a very simple and safe way in which the programmer can obtain mutual exclusion (Axford 1987). </s></p><div4><head rend="underlined">Monitor structure</head><p n="p19.74"><s n="s1.1;p19.74">The monitor consists of: </s></p><list type="bulleted"><item>The shared variables associated with the resource</item><item>A set of procedures which can operate on the shared variables</item></list><p n="p20.74"><s n="s1.1;p20.74"><formula notation="" id="BAWE_6170c-form.004"/> </s></p></div4><div4><head rend="underlined">How the monitor works</head><p n="p21.74"><s n="s1.3;p21.74">The key point of monitor approach to synchronization is that only monitor's procedures can access the shared variables. </s><s n="s2.3;p21.74">Only one process can run monitor's procedure at a time. </s><s n="s3.3;p21.74">It guarantees the mutual exclusion. </s></p><p n="p22.74"><s n="s1.2;p22.74">If one process is running the monitor's procedure, no other process can run any procedure of this monitor until the first one finishes and leaves the monitor. </s><s n="s2.2;p22.74">It makes the use of shared variables easier for programmers - they do not need to assure the exclusive use of shared resources, it is enough to place them inside the monitor which will automatically take care for that. </s></p><p n="p23.74"><s n="s1.1;p23.74">In case when a process wants to run monitor's procedure which is currently used by another process, its request is put on queue. </s></p></div4><div4><head rend="underlined">Condition variables</head><p n="p24.74"><s n="s1.3;p24.74">Monitors also have condition variables, on which a process can wait if conditions are not right for it to continue executing in the monitor. </s><s n="s2.3;p24.74">Some other process can then get in the monitor and perhaps change the state of the monitor. </s><s n="s3.3;p24.74">If conditions are now right, that process can signal a waiting process, moving the latter to the ready queue to get back into the monitor when it becomes free (Hartley 1997). </s></p></div4><div4><head rend="underlined">Operations on condition variables</head><p n="p25.74"><s n="s1.1;p25.74">We can perform the following operations on condition variables: </s></p><list type="bulleted"><item>wait(c) - it results in adding the calling process to the queue. It releases the monitor what means that other processes can now access it. </item><item>signal(c) - it removes the head process from the queue. In case the queue is empty it does not cause any result. The awaken process resumes execution of instruction following after wait(c). </item><item>signal_all(c) - (sometimes referred to as broadcast signal) it removes all processes from the queue. It has no effect if the queue is empty.</item><item>empty(c) - it is a logical function. It returns true in case there are no processes in the queue. </item></list><p n="p26.74"><s n="s1.1;p26.74">Even though wait(c) and signal(c) look similar to P(s) and V(s) there are crucial differences between them (Andrews 1991): </s></p><list type="bulleted"><item>signal(c) gives no results in case the queue is empty (whereas the semaphore would be increased)</item><item>wait(c) always delays the process until signal(c) is executed (whereas P(s) delays the process only if s=0)</item></list></div4></div3><div3><head rend="bold">Message passing</head><p n="p27.74"><s n="s1.3;p27.74">So far I have described solutions which can be used only in a shared memory environment. </s><s n="s2.3;p27.74">Nowadays, when network architectures are becoming more and more popular, a new solution needed to be introduced. </s><s n="s3.3;p27.74">This is where the message passing evolved. </s></p><p n="p28.74"><s n="s1.2;p28.74">Sometimes it might be also convenient that processes executing on the shared memory architecture use the message passing as communication and synchronisation mechanism instead of using the shared variables. </s><s n="s2.2;p28.74">It happens e.g. when processes are executing on behalf of different users (Andrews 1991:339). </s></p><div4><head rend="underlined">Message passing operations</head><p n="p29.74"><s n="s1.1;p29.74">The primitives operations for message passing mechanism are: </s></p><list type="bulleted"><item>send (destination, message)</item><item>receive (source, message)</item></list></div4><div4><head rend="underlined">How the message passing works</head><p n="p30.74"><s n="s1.2;p30.74">In case of message passing mechanism processes share channels. </s><s n="s2.2;p30.74">To initiate communication one process sends a message to a channel; another process acquires the message by receiving it from the channel (Andrews 1991:339). </s></p></div4><div4><head rend="underlined">Message passing models</head><p n="p31.74"><s n="s1.1;p31.74">There are three message passing models: </s></p><list type="bulleted"><item>synchronous</item><item>asynchronous</item><item>buffered </item></list><p n="p32.74"><s n="s1.5;p32.74">In <hi rend="bold">asynchronous message passing</hi>, channels are unbounded queues of messages. </s><s n="s2.5;p32.74">Execution of each <hi rend="italic">send</hi> statement attaches a message to a queue. </s><s n="s3.5;p32.74">As the channels are supposed to be unbounded the sender is not delayed. </s><s n="s4.5;p32.74">To receive the message the process executes <hi rend="italic">receive</hi> statement. </s><s n="s5.5;p32.74">If the channel is empty the receiver is delayed. </s></p><p n="p33.74"><s n="s1.1;p33.74">Using the asynchronous message passing model has three major disadvantages: </s></p><list type="ordered"><item>We can get the situation in which the receiver is far behind the sender. </item><item>The sending process does not known about any failures that can occur during transmission.</item><item>There is a need to buffer the messages. It is obvious that buffers are not infinite therefore in case of sending too many messages the programme can either crash or <hi rend="italic">send</hi> will be blocked.</item></list><p n="p34.74"><s n="s1.3;p34.74">In <hi rend="bold">synchronous message passing</hi> we can avoid these problems. </s><s n="s2.3;p34.74">In this model both <hi rend="italic">send</hi> and <hi rend="italic">receive</hi> statement are blocking primitives. </s><s n="s3.3;p34.74">The communication is performed synchronously that means that the sender blocks until the receiver does a <hi rend="italic">receive</hi> and the receiver blocks until the sender does a <hi rend="italic">send</hi>. </s></p><p n="p35.74"><s n="s1.3;p35.74">In <hi rend="bold">buffered message passing</hi> the channel has a fixed capacity. </s><s n="s2.3;p35.74">In case the channel is full the sender is delayed. </s><s n="s3.3;p35.74">If the channel is empty the receiver is delayed. </s></p></div4></div3></div2><div2><head rend="bold italic">The significance of Formal Methods in designing safety critical Real Time &amp; Concurrent software systems</head><p n="p36.74"><s n="s1.4;p36.74">While designing new software, the main goal for the software engineer is to ensure that his product is reliable and predictable. </s><s n="s2.4;p36.74">Therefore he must make sure that all design flaws are eliminated. </s><s n="s3.4;p36.74">Unfortunately the more complex the system is, the more difficult it is to ensure its correct performance. </s><s n="s4.4;p36.74">There are three main approaches in handling the design flaws: </s></p><list type="bulleted"><item>testing</item><item>design diversity</item><item>fault avoidance</item></list><p n="p37.74"><s n="s1.2;p37.74">Several researches have shown that the fault avoidance approach is the best one to use for high integrity systems. </s><s n="s2.2;p37.74"><hi rend="bold">Formal Methods</hi> are the most rigorous of all fault avoidance approaches and therefore they are most hopeful. </s></p><p n="p38.74"><s n="s1.3;p38.74">Using the computers for monitoring and controlling safety critical system is a convenient solution on one hand, but very dangerous on the other. </s><s n="s2.3;p38.74">Making a computer system responsible for controlling planes, medical devices or nuclear power plant puts our life in risk. </s><s n="s3.3;p38.74">Even a single bug can be considerably hazardous. </s></p><p n="p39.74"><s n="s1.2;p39.74">Therefore the Formal Methods - as most promising - should be used in all applications where even a single error can be critical to the system or worse - to our life. </s><s n="s2.2;p39.74">The software engineers must never forget that their products control several systems that influence our life: trains, planes, medical equipment. </s></p><p n="p40.74"><s n="s1.1;p40.74">Formal Methods are mathematical techniques and tools used for: </s></p><list type="bulleted"><item>specification</item><item>design</item><item>verification </item></list><p n="p41.74"><s n="s1.2;p41.74">of software and hardware systems (Butler 2001). </s><s n="s2.2;p41.74">The aim of formalization is to decrease the risk of severe specification and design errors. </s></p><p n="p42.74"><s n="s1.3;p42.74">Even though the use of Formal Methods is relatively difficult and expensive, it also gives numerous benefits. </s><s n="s2.3;p42.74">The Formal Methods enable verifying system correctness by mathematical methods, which is a much more reliable approach than system testing. </s><s n="s3.3;p42.74">Thanks to using Formal Methods </s></p><list type="bulleted"><item>the defects can be found earlier and therefore its correction is easier and less expensive</item><item>certain properties of the system can be checked automatically</item><item>the rework is decreased </item></list><p n="p43.74"><s n="s1.2;p43.74">Without use of Formal Methods the requirements are written in informal manner. </s><s n="s2.2;p43.74">Such approach can be very risky as the specification is then: </s></p><list type="bulleted"><item>too general - it does not precise how to satisfy the requirements</item><item>not accurate enough - different people can interpret it differently</item></list><p n="p44.74"><s n="s1.4;p44.74">A way to avoid these problems is to employ Formal Methods. </s><s n="s2.4;p44.74">Formal Methods are very specific; they make designers think about the problem more thoroughly as they are supposed to describe the problem in precise formal language. </s><s n="s3.4;p44.74">Specification expressed in mathematical notations is a very accurate description of desirable behaviour. </s><s n="s4.4;p44.74">It has been proved that formalisation improves system quality, consistency and integrity. </s></p><p n="p45.74"><s n="s1.1;p45.74">There are many different Formal Methods to choose from: </s></p><list type="bulleted"><item>Abstract State Machines</item><item>B-Method</item><item>CommUnity</item><item>Lotos</item><item>Petri Nets</item><item>SDL</item><item>TRIO</item><item>VDM</item><item>Z</item></list><p n="p46.74"><s n="s1.1;p46.74">Once it is decided to use Formal Methods for the project, we need to think which one to use. </s></p></div2></div1><div1 type="section"><head rend="bold">Part 2: Real-time application</head><div2><head rend="bold italic">A detailed explanation of the application</head><div3><head>GREENHOUSE SYSTEM</head><p n="p47.74"><s n="s1.1;p47.74">The real-time application that I am going to describe is the Greenhouse System. </s></p><p n="p48.74"><s n="s1.2;p48.74">As greenhouse is supposed to provide "weather conditions" suitable for cultivating plants there is a strong need to monitor and control these conditions. </s><s n="s2.2;p48.74">Therefore the real-time system will be designed. </s></p><p n="p49.74"><s n="s1.5;p49.74">This system will be used to monitor and control the current conditions inside the greenhouse. </s><s n="s2.5;p49.74">It analyses (Analyser) information provided by sensors (Sensor Monitor) and based on it decides what action should be taken (Decision System). </s><s n="s3.5;p49.74">The actions are taken if data is incorrect (conditions are different from desired). </s><s n="s4.5;p49.74">In case of major variances between current and desired conditions the failure will be detected (Check for Failure) and the alarm will be activated (Activate Alarm). </s><s n="s5.5;p49.74">All sensors of each type provide information simultaneously and the system must respond within given time limits. </s></p><p n="p50.74"><s n="s1.4;p50.74">The Greenhouse System is an example of a soft real-time system. </s><s n="s2.4;p50.74">It means that any time delay does not cause any critical error but only decreases the quality of the service. </s><s n="s3.4;p50.74">It is not that critical for the greenhouse if e.g. the temperature is a little bit too low for while and that the heating will be turned on a minute later. </s><s n="s4.4;p50.74">Therefore it is assumed that the sensors will be read every 5 minutes and that the system should analyse the data and take suitable actions within 3 minutes. </s></p><p n="p51.74"><s n="s1.1;p51.74">The following <hi rend="bold">processes</hi> will be monitored and controlled in the Greenhouse System: </s></p><list type="simple"><item>Temperature-sensor monitor - checks the temperatures and sends the data from all sensors to the temperature analyser</item><item>Humidity-sensor monitor - checks the humidity and sends the data from all sensors to humidity analyser</item><item>CO <hi rend="sub">2</hi> - sensor monitor - checks the level of CO <hi rend="sub">2</hi> and sends the data from all sensors to CO <hi rend="sub">2</hi> analyser</item><item>Light-exposure sensor monitor - checks the light exposure and sends the data from all sensors to light analyser</item><item>Temperature Analyser - collects information from temperature monitor. It compares the reading from each sensor with the expected value and sends the difference to Heating/Cooling Decision System</item><item>Humidity Analyser - collects information from humidity monitor. It compares the reading from each sensor with the expected value and sends the difference to Humidifying/Drying Decision System</item><item>CO <hi rend="sub">2</hi> Analyser - collects information from CO <hi rend="sub">2</hi> monitor. It compares the reading from each sensor with the expected value and sends the difference to Air Exchange Decision System</item><item>Light Analyser - collects information from light monitor. . It compares the reading from each sensor with the expected value and sends the difference to Change Light Exposure Decision System</item><item>Time Analyser checks the current time and compares it with time set by administrator for activating irrigation and sends the data Irrigation Decision System</item><item>Heating/Cooling Decision System - receives data from Temperature Analyser and based on it decides whether to activate radiators or not</item><item>Humidifying/Drying Decision System - receives data from Humidity Analyser and based on it decides whether to activate humidifier or not</item><item>Change light exposure Decision System - receives data from Light Analyser and based on it decides whether to change the light exposure or not</item><item>Air exchange Decision System - receives data from CO <hi rend="sub">2</hi> Analyser and based on it decides whether to exchange air or not</item><item>Irrigation Decision System - receives data from Time Analyser and based on it decides whether to activate irrigation or not</item><item>Check for failure - this process checks if there are any failures e.g. data collected from at least one of sensors placed all around the greenhouse is totally different from expected. The highest acceptable variance between current and desired parameters is set by the user. If the failure occurs the alarm is activated and the failure is reported</item><item>Report - all data collected from the sensors and analysed and are placed in the report automatically. Also the user can have access to the data. </item><item>Activate alarm - this process informs the greenhouse owner/administrator that the failure has occurred by turning on the alarm.</item></list><p n="p52.74"><s n="s1.1;p52.74">The system contains the user console so that the system administrator can define: </s></p><list type="bulleted"><item>desired temperatures Temp</item><item>desired humidity Hum</item><item>desired level of CO <hi rend="sub">2</hi> Lev</item><item>desired light exposure Light</item><item>times when the irrigation system is activated Time</item><item>the highest acceptable variances between current and desired</item><item> temperatures ΔTemp</item><item>humidity ΔHum</item><item>level of CO <hi rend="sub">2 </hi>ΔLev</item><item>light exposure ΔLight</item></list><p n="p53.74"><s n="s1.1;p53.74">If the variance is higher than acceptable the alarm will be activated </s></p><p n="p54.74"><s n="s1.1;p54.74">Administrator can also request the report data. </s></p><div4><head rend="bold">The exemplary scenario 1 (a failure detected)</head><list type="ordered"><item>The desired data parameters are set with the user console e.g.:</item><item>Temp </item><item>Hum </item><item>Light </item><item>Lev</item><item>Time (when the irrigation is activated) </item><item>ΔTemp</item><item>ΔHum</item><item>ΔLight</item><item>Δ CO <hi rend="sub">2 </hi></item><item>Monitors read the sensors</item><item>Current parameters from Monitors and the clock are sent to Analysers </item><item>Analyse the data</item><item>Difference between expected and current temperature is bigger than acceptable Δtemp > ΔTemp - failure detected</item><item>Activate alarm and report data</item></list><p n="p55.74"/></div4><div4><head rend="bold">The exemplary scenario 2 (no failure detected, but the temperature too low)</head><list type="ordered"><item>The desired data parameters are set with the user console:</item><item>Temp </item><item>Hum </item><item>Light </item><item>Lev </item><item>Time (when the irrigation is activated) </item><item>ΔTemp</item><item>ΔHum</item><item>ΔLight</item><item>ΔLev </item><item>Monitors read the sensors</item><item>Current parameters from Monitors and the clock are sent to Analysers </item><item>Analyse the data by comparison:</item><item> the temperatures: desired - Temp and current - temp</item><item>the humidity: desired - Hum and current - hum</item><item>the light exposure: desired - Light and current - light</item><item>the CO <hi rend="sub">2</hi> level: desired - Lev and current - lev</item><item>current time with the administrator settings Time for irrigation system</item><item>The results are:</item><item>Temp > temp </item><item>Hum = hum</item><item>Light = light</item><item>Lev = lev</item><item>Time ≠ time - no need to activate the irrigation system</item><item>Send the following data to Report, Decision System and Check for Failure</item><item>Δtemp = Temp - temp = 2° C</item><item>Δhum = 0 </item><item>Δlight = 0</item><item>Δlev = 0 </item><item>Time ≠ time</item><item>Check for failure:</item><item>Δtemp &lt; ΔTemp - no failure</item><item>Δhum &lt; ΔHum - no failure</item><item>Δlight &lt; ΔLight - no failure</item><item>Δlev &lt; ΔLev - no failure</item><item>The Decision System orders:</item><item>to activate heating due to the temperature difference</item><item>not to activate humidifiers</item><item>not to activate air exchange</item><item>not to change the light exposure</item><item>not to activate irrigation system</item><item>Monitors read the sensors</item><item>...</item></list><p n="p56.74"/></div4></div3></div2><div2><head rend="bold italic">Data flow diagram, inputs and outputs</head><p n="p57.74"><s n="s1.1;p57.74"><hi rend="italic">Figure 1</hi> shows the general Data Flow Diagram of the whole system: </s></p><list type="ordered"><item>The administrator sets the desired parameters</item><item>Sensor Monitors and a clock provide the current parameters inside the greenhouse to Data Analyser</item><item>Data Analyser compares the actual data with desired ones.</item><item>The compared data are sent to Decision System, Check for Failure and are added to Report</item><item>Decision System is responsible for activating heating/cooling, humidifying/drying, air exchange, changing light exposure and activating irrigation</item><item>The analysed data are checked for major variances (Check for Failure) and in case they appear the alarm is activated</item><item>All data from Check for Failure and Data Analyser are written in the report.</item></list><figure id="BAWE_6170c-fig.001"><head rend="italic">Figure 1</head></figure><p n="p58.74"><s n="s1.1;p58.74">"Sensor monitor" is a generic name for the whole set of processes shown at <hi rend="italic">Figure 2</hi>: </s></p><figure id="BAWE_6170c-fig.002"><head rend="italic">Figure 2</head></figure><p n="p59.74"><s n="s1.1;p59.74">"Data analyser" is a generic name for the whole set of processes shown at <hi rend="italic">Figure 3</hi>: </s></p><figure id="BAWE_6170c-fig.003"><head rend="italic">Figure 3</head></figure><p n="p60.74"><s n="s1.1;p60.74">"Decision System" is a generic name for the whole set of processes shown at <hi rend="italic">Figure4</hi>: </s></p><figure id="BAWE_6170c-fig.004"><head rend="italic">Figure 4</head></figure><p n="p61.74"><s n="s1.1;p61.74">In the following table I will show inputs and outputs of all processes: </s></p><table id="BAWE_6170c-tab.001"><row><cell/></row></table></div2></div1><div1 type="section"><head rend="bold">Part 3: Definition of concurrent processes and synchronisation mechanism. </head><div2><head rend="bold italic">Concurrent processes definition. Communication and synchronization mechanisms</head><p n="p62.74"><s n="s1.5;p62.74">In the Greenhouse System there are many concurrent processes. </s><s n="s2.5;p62.74">In fact all of them (excluding Activate Alarm) are running simultaneously. </s><s n="s3.5;p62.74">All the processes contained in Sensor Monitor are executed at the same time (e.g. every 5 minutes). </s><s n="s4.5;p62.74">Than all processes gathered in Data Analyser analyse the data at the same time. </s><s n="s5.5;p62.74">Another set of concurrent processes is grouped within Decision System. </s></p><p n="p63.74"><s n="s1.2;p63.74">In this part of the coursework I will write a programme using SR language to show how the processes communicate and synchronise their access to shared variables. </s><s n="s2.2;p63.74">In order to provide mutual exclusion semaphores will be implemented. </s></p><p n="p64.74"><s n="s1.1;p64.74">I choose the following processes: </s></p><list type="ordered"><item>Analyse Current Temperature</item><item>Change Desired Conditions </item><item>Reading Report</item></list><p rend="ordered" n="p65.74"><s n="s1.2;p65.74">This process is similar to all the processes from its group and all of them would be implemented in the same way. </s><s n="s2.2;p65.74">This process has access to the following shared data: </s></p><p rend="ordered" n="p66.74"><s n="s1.1;p66.74">desired temperature which is set in Change Desired Conditions process </s></p><p rend="ordered" n="p67.74"><s n="s1.1;p67.74">Report which can be read by the system administrator. </s></p><p rend="ordered" n="p68.74"><s n="s1.3;p68.74">In this case temperature is the only desired parameter that is changed. </s><s n="s2.3;p68.74">In the same way we can change all the desired parameters (each parameter must have its own semaphore). </s><s n="s3.3;p68.74">Temperature is of course the shared data. </s></p><p rend="ordered" n="p69.74"><s n="s1.1;p69.74">The administrator can read the report which is also a shared resource. </s></p><p n="p70.74"><s n="s1.1;p70.74">To implement these processes I need to use two semaphores: </s></p><list type="bulleted"><item>One for desired temperature - two processes have access to this variable: Change Desired Condition and Analyse Current Temperature. While the desired temperature is being changed it cannot be accessed for comparison purposes. </item><item>One for Report - two processes have access to this variable: Analyse Current Temperature and Reading Report. While the data are added to the report it cannot be read by the administrator. </item></list></div2><div2><head rend="bold italic">SR code</head><p n="p71.74"><s n="s1.1;p71.74">The programme in SR: </s></p><p n="p72.74"><s n="s1.1;p72.74"><formula notation="" id="BAWE_6170c-form.005"/> </s></p><p n="p73.74"><s n="s1.1;p73.74">A part of output from the programme: </s></p><p n="p74.74"><s n="s1.1;p74.74"><formula notation="" id="BAWE_6170c-form.006"/> </s></p></div2></div1></body><back><div1 type="bibliography"><head rend="bold">References</head><p>Andrews, R.G. (1991) <hi rend="italic">Concurrent Programming. Principles and Practise.</hi> Menlo Park: Addison-Wesley Publishing Company</p><p>Axford, T. (1991) <hi rend="italic">Concurrent Programming. Fundamental Techniques for Real-Time and Parallel Software Design</hi> Chichester: John Wiley and Sons </p><p>Butler, R. W. (2001) [online] available from <seg type="URL" n="http://shemesh.larc.nasa.gov/fm/fm-what.html"/> [4 January 2007]</p><p>Hartley, S. (1997) [online] available from <seg type="URL" n="www.mcs.drexel.edu"/> [5 January 2007]</p></div1></back></text></TEI.2>
